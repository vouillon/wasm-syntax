module Comments : sig
  type t
  (** A mutable collection of comments and blank lines. *)

  val create : unit -> t
  (** Creates a new empty collection. *)

  val add_line_comment : t -> string -> Ast.location -> unit
  (** Adds a line comment to the collection. *)

  val add_block_comment : t -> string -> Ast.location -> unit
  (** Adds a block comment to the collection. *)

  val add_newline : t -> Ast.location -> unit
  (** Adds a newline (potential blank line) to the collection. *)

  val visit_token : t -> Ast.location -> unit
  (** Updates the internal state (e.g. last line number) based on a visited
      normal token. *)
end

type t
(** The state of the pretty-printer, managing indentation, pending
    spaces/newlines, and attached comments/blank lines. *)

val indent : t -> int -> (unit -> unit) -> unit
(** [indent pp indent f] executes the function [f] with the current indentation
    level increased by [indent]. The indentation level is restored after [f]
    completes. *)

val string : t -> string -> unit
(** Prints a string to the formatter, flushing any pending items first. *)

val string_as : t -> int -> string -> unit
(** Prints a string with a specified display length to the formatter. *)

val space : t -> unit -> unit
(** Queues a space to be printed, if no newlines are pending and a non-blank
    string has been emitted. *)

val newline : t -> unit -> unit
(** Queues a hard break (newline) to be printed. *)

val blank_line : t -> unit -> unit
(** Queues a blank line (two newlines) to be printed. *)

val cut : t -> unit -> unit
(** Prints a cut (break with 0 width) to the formatter. *)

val box : t -> ?skip_space:bool -> ?indent:int -> (unit -> unit) -> unit
(** [box pp ?skip_space ?indent f] creates a "box" for pretty-printing. The
    content generated by [f] will be formatted within this box. If it fits on a
    single line, it will be printed on one line. Otherwise, it will be broken
    into multiple lines. [?indent] specifies an additional indentation level for
    lines broken within the box. If [?skip_space] is true, no space will be
    added before the box if it starts on the same line as previous content. *)

val hvbox : t -> ?skip_space:bool -> ?indent:int -> (unit -> unit) -> unit
(** [hvbox pp ?skip_space ?indent f] creates a "horizontal-vertical" box. The
    content generated by [f] will be formatted horizontally if it fits on the
    current line; otherwise, it will be formatted vertically, breaking lines
    where appropriate. [?indent] specifies an additional indentation level for
    lines broken within the box. If [?skip_space] is true, no space will be
    added before the box. *)

val vbox : t -> ?skip_space:bool -> ?indent:int -> (unit -> unit) -> unit
(** [vbox pp ?skip_space ?indent f] creates a "vertical" box. The content
    generated by [f] will always be formatted vertically, breaking lines where
    appropriate. [?indent] specifies an additional indentation level for lines
    broken within the box. If [?skip_space] is true, no space will be added
    before the box. *)

val node : t -> int -> (unit -> unit) -> unit
(** Prints a node, consuming any preceding comments/blank lines. *)

val inline_comments : t -> int -> unit
(** Prints inline comments that occur before the given character offset. *)

val catchup : t -> int -> unit
(** Advances the printer output, consuming comments and blank lines up to a
    certain character offset. *)

val remaining_comments : t -> unit
(** Prints any remaining comments and blank lines after all nodes have been
    processed. *)

val run : ?comments:Comments.t -> Format.formatter -> (t -> unit) -> unit
(** [run ?comments fmt f] creates a new printer, runs [f] with it, and flushes
    the printer. *)
