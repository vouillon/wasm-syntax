(module
  (import "fail" "caml_failwith" (func $caml_failwith (param (ref eq))))
  (import "custom" "custom_compare_id"
    (func $custom_compare_id (param (ref eq) (ref eq) i32) (result i32))
  )
  (import "custom" "custom_hash_id"
    (func $custom_hash_id (param (ref eq)) (result i32))
  )
  (import "custom" "custom_next_id" (func $custom_next_id (result i64)))
  (type $string (array (mut i8)))
  (type $compare (func (param (ref eq) (ref eq) i32) (result i32)))
  (type $hash (func (param (ref eq)) (result i32)))
  (type $fixed_length (struct (field $bsize_32 i32) (field $bsize_64 i32)))
  (type $serialize (func (param (ref eq) (ref eq)) (result i32 i32)))
  (type $deserialize (func (param (ref eq)) (result (ref eq) i32)))
  (type $dup (func (param (ref eq)) (result (ref eq))))
  (type $custom_operations
    (struct
      (field $id (ref $string))
      (field $compare (ref null $compare))
      (field $compare_ext (ref null $compare))
      (field $hash (ref null $hash))
      (field $fixed_length (ref null $fixed_length))
      (field $serialize (ref null $serialize))
      (field $deserialize (ref null $deserialize))
      (field $dup (ref null $dup)))
  )
  (type $custom (sub (struct (field $f (ref $custom_operations)))))
  (type $custom_with_id
    (sub $custom (struct (field $f (ref $custom_operations)) (field $id i64)))
  )
  (global $mutex_ops (ref $custom_operations)
    (struct.new $custom_operations (@string $string "_mutex" )
      (ref.func $custom_compare_id) (ref.null $compare)
      (ref.func $custom_hash_id) (ref.null $fixed_length)
      (ref.null $serialize) (ref.null $deserialize) (ref.null $dup))
  )
  (type $mutex
    (sub final $custom_with_id
      (struct
        (field $f (ref $custom_operations))
        (field $f_2 i64)
        (field $state (mut i32))))
  )
  (func $caml_ml_mutex_new (export "caml_ml_mutex_new")
    (param $x (ref eq)) (result (ref eq))
    (struct.new $mutex (global.get $mutex_ops) (call $custom_next_id)
      (i32.const 0))
  )
  (func $caml_ml_mutex_lock (export "caml_ml_mutex_lock")
    (param $x (ref eq)) (result (ref eq))
    (local $t (ref $mutex))
    (local.set $t (ref.cast (ref $mutex) (local.get $x)))
    (if (struct.get $mutex $state (local.get $t))
      (then (call $caml_failwith (@string $string "foo" ))))
    (struct.set $mutex $state (local.get $t) (i32.const 1))
    (ref.i31 (i32.const 0))
  )
  (func $caml_ml_mutex_try_lock (export "caml_ml_mutex_try_lock")
    (param $x (ref eq)) (result (ref eq))
    (local $t (ref $mutex))
    (local.set $t (ref.cast (ref $mutex) (local.get $x)))
    (if (result (ref eq)) (struct.get $mutex $state (local.get $t))
      (then (ref.i31 (i32.const 0)))
      (else
        (struct.set $mutex $state (local.get $t) (i32.const 1))
        (ref.i31 (i32.const 1))))
  )
  (func $caml_ml_mutex_unlock (export "caml_ml_mutex_unlock")
    (param $x (ref eq)) (result (ref eq))
    (struct.set $mutex $state (ref.cast (ref $mutex) (local.get $x))
      (i32.const 0))
    (ref.i31 (i32.const 0))
  )
  (func $caml_ml_condition_new (export "caml_ml_condition_new")
    (param $x (ref eq)) (result (ref eq))
    (ref.i31 (i32.const 0))
  )
  (func $caml_ml_condition_wait (export "caml_ml_condition_wait")
    (param $x (ref eq)) (param $x_2 (ref eq)) (result (ref eq))
    (call $caml_failwith (@string $string "foo" ))
    (ref.i31 (i32.const 0))
  )
  (func $caml_ml_condition_signal (export "caml_ml_condition_signal")
    (param $x (ref eq)) (result (ref eq))
    (ref.i31 (i32.const 0))
  )
  (func $caml_ml_condition_broadcast (export "caml_ml_condition_broadcast")
    (param $x (ref eq)) (result (ref eq))
    (ref.i31 (i32.const 0))
  )
)
