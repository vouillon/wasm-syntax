#[import = ("io", "caml_getblock")]
fn caml_getblock(_: &eq, _: &string, _: i32, _: i32) -> i32
#[import = ("fail", "caml_raise_end_of_file")] fn caml_raise_end_of_file()
type string = [mut i8]
type int_array = [mut i32]
type context = { f: &int_array, f_2: mut i64, f_3: &int_array, f_4: &string }
#[export = "caml_md5_string"]
#[export = "caml_md5_bytes"]
fn caml_md5_string(x: &eq, x_2: &eq, x_3: &eq) -> &eq {
    let ctx: &context;
    ctx = MD5Init();
    MD5Update(ctx, x as &string, x_2 as &i31 as i32_u, x_3 as &i31 as i32_u);
    become MD5Final(ctx);
}
#[export = "caml_md5_chan"]
fn caml_md5_chan(ch: &eq, vlen: &eq) -> &eq {
    let len: i32;
    let read: i32;
    let buf: &string;
    let ctx: &context;
    len = vlen as &i31 as i32_s;
    buf = [string|0; 4096];
    ctx = MD5Init();
    if len <s 0 {
        'loop: loop {
            read = caml_getblock(ch, buf, 0, 4096);
            if read { MD5Update(ctx, buf, 0, read); br 'loop; }
        } /* 'loop */
    } else {
        'loop: loop {
            if len {
                read = caml_getblock(ch, buf, 0, len <=u 4096?len:4096);
                if !read { caml_raise_end_of_file(); }
                MD5Update(ctx, buf, 0, read);
                len = len - read;
                br 'loop;
            }
        } /* 'loop */
    }
    become MD5Final(ctx);
}
fn xx(q: i32, a: i32, b: i32, x: i32, s: i32, t: i32) -> i32 {
    rotl(a + q + (x + t), s) + b;
}
fn ff(a: i32, b: i32, c: i32, d: i32, x: i32, s: i32, t: i32) -> i32 {
    xx(d ^ b & (c ^ d), a, b, x, s, t);
}
fn gg(a: i32, b: i32, c: i32, d: i32, x: i32, s: i32, t: i32) -> i32 {
    xx(c ^ d & (b ^ c), a, b, x, s, t);
}
fn hh(a: i32, b: i32, c: i32, d: i32, x: i32, s: i32, t: i32) -> i32 {
    xx(b ^ (c ^ d), a, b, x, s, t);
}
fn ii(a: i32, b: i32, c: i32, d: i32, x: i32, s: i32, t: i32) -> i32 {
    xx(c ^ (b | d ^ -1), a, b, x, s, t);
}
fn get_32(s: &string, p: i32) -> i32 {
    s[p] as i32_u | s[p + 1] as i32_u << 8 |
        (s[p + 2] as i32_u << 16 | s[p + 3] as i32_u << 24);
}
fn MD5Transform(w: &int_array, buffer: &int_array, buffer': &string, p: i32)
{
    let i: i32;
    let a: i32;
    let b: i32;
    let c: i32;
    let d: i32;
    'loop: loop {
        buffer[i] = get_32(buffer', p);
        i = i + 1;
        p = p + 4;
        br_if 'loop i <u 16;
    }
    a = w[0];
    b = w[1];
    c = w[2];
    d = w[3];
    a = ff(a, b, c, d, buffer[0], 7, 0xD76AA478);
    d = ff(d, a, b, c, buffer[1], 12, 0xE8C7B756);
    c = ff(c, d, a, b, buffer[2], 17, 0x242070DB);
    b = ff(b, c, d, a, buffer[3], 22, 0xC1BDCEEE);
    a = ff(a, b, c, d, buffer[4], 7, 0xF57C0FAF);
    d = ff(d, a, b, c, buffer[5], 12, 0x4787C62A);
    c = ff(c, d, a, b, buffer[6], 17, 0xA8304613);
    b = ff(b, c, d, a, buffer[7], 22, 0xFD469501);
    a = ff(a, b, c, d, buffer[8], 7, 0x698098D8);
    d = ff(d, a, b, c, buffer[9], 12, 0x8B44F7AF);
    c = ff(c, d, a, b, buffer[10], 17, 0xFFFF5BB1);
    b = ff(b, c, d, a, buffer[11], 22, 0x895CD7BE);
    a = ff(a, b, c, d, buffer[12], 7, 0x6B901122);
    d = ff(d, a, b, c, buffer[13], 12, 0xFD987193);
    c = ff(c, d, a, b, buffer[14], 17, 0xA679438E);
    b = ff(b, c, d, a, buffer[15], 22, 0x49B40821);
    a = gg(a, b, c, d, buffer[1], 5, 0xF61E2562);
    d = gg(d, a, b, c, buffer[6], 9, 0xC040B340);
    c = gg(c, d, a, b, buffer[11], 14, 0x265E5A51);
    b = gg(b, c, d, a, buffer[0], 20, 0xE9B6C7AA);
    a = gg(a, b, c, d, buffer[5], 5, 0xD62F105D);
    d = gg(d, a, b, c, buffer[10], 9, 0x02441453);
    c = gg(c, d, a, b, buffer[15], 14, 0xD8A1E681);
    b = gg(b, c, d, a, buffer[4], 20, 0xE7D3FBC8);
    a = gg(a, b, c, d, buffer[9], 5, 0x21E1CDE6);
    d = gg(d, a, b, c, buffer[14], 9, 0xC33707D6);
    c = gg(c, d, a, b, buffer[3], 14, 0xF4D50D87);
    b = gg(b, c, d, a, buffer[8], 20, 0x455A14ED);
    a = gg(a, b, c, d, buffer[13], 5, 0xA9E3E905);
    d = gg(d, a, b, c, buffer[2], 9, 0xFCEFA3F8);
    c = gg(c, d, a, b, buffer[7], 14, 0x676F02D9);
    b = gg(b, c, d, a, buffer[12], 20, 0x8D2A4C8A);
    a = hh(a, b, c, d, buffer[5], 4, 0xFFFA3942);
    d = hh(d, a, b, c, buffer[8], 11, 0x8771F681);
    c = hh(c, d, a, b, buffer[11], 16, 0x6D9D6122);
    b = hh(b, c, d, a, buffer[14], 23, 0xFDE5380C);
    a = hh(a, b, c, d, buffer[1], 4, 0xA4BEEA44);
    d = hh(d, a, b, c, buffer[4], 11, 0x4BDECFA9);
    c = hh(c, d, a, b, buffer[7], 16, 0xF6BB4B60);
    b = hh(b, c, d, a, buffer[10], 23, 0xBEBFBC70);
    a = hh(a, b, c, d, buffer[13], 4, 0x289B7EC6);
    d = hh(d, a, b, c, buffer[0], 11, 0xEAA127FA);
    c = hh(c, d, a, b, buffer[3], 16, 0xD4EF3085);
    b = hh(b, c, d, a, buffer[6], 23, 0x04881D05);
    a = hh(a, b, c, d, buffer[9], 4, 0xD9D4D039);
    d = hh(d, a, b, c, buffer[12], 11, 0xE6DB99E5);
    c = hh(c, d, a, b, buffer[15], 16, 0x1FA27CF8);
    b = hh(b, c, d, a, buffer[2], 23, 0xC4AC5665);
    a = ii(a, b, c, d, buffer[0], 6, 0xF4292244);
    d = ii(d, a, b, c, buffer[7], 10, 0x432AFF97);
    c = ii(c, d, a, b, buffer[14], 15, 0xAB9423A7);
    b = ii(b, c, d, a, buffer[5], 21, 0xFC93A039);
    a = ii(a, b, c, d, buffer[12], 6, 0x655B59C3);
    d = ii(d, a, b, c, buffer[3], 10, 0x8F0CCC92);
    c = ii(c, d, a, b, buffer[10], 15, 0xFFEFF47D);
    b = ii(b, c, d, a, buffer[1], 21, 0x85845DD1);
    a = ii(a, b, c, d, buffer[8], 6, 0x6FA87E4F);
    d = ii(d, a, b, c, buffer[15], 10, 0xFE2CE6E0);
    c = ii(c, d, a, b, buffer[6], 15, 0xA3014314);
    b = ii(b, c, d, a, buffer[13], 21, 0x4E0811A1);
    a = ii(a, b, c, d, buffer[4], 6, 0xF7537E82);
    d = ii(d, a, b, c, buffer[11], 10, 0xBD3AF235);
    c = ii(c, d, a, b, buffer[2], 15, 0x2AD7D2BB);
    b = ii(b, c, d, a, buffer[9], 21, 0xEB86D391);
    w[0] = w[0] + a;
    w[1] = w[1] + b;
    w[2] = w[2] + c;
    w[3] = w[3] + d;
}
fn MD5Init() -> &context {
    {context|
        f: [int_array|0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476],
        f_2: 0,
        f_3: [int_array|0; 16],
        f_4: [string|0; 64]
    };
}
fn MD5Update(ctx: &context, input: &string, input_pos: i32, input_len: i32) {
    let in_buf: i32;
    let len: i64;
    let missing: i32;
    len = ctx.f_2;
    in_buf = len as i32 & 0x3f;
    ctx.f_2 = len + input_len as i64_u;
    if in_buf {
        missing = 64 - in_buf;
        if input_len <u missing {
            ctx.f_4.copy(missing, input, input_pos, input_len);
            return;
        }
        ctx.f_4.copy(missing, input, input_pos, missing);
        MD5Transform(ctx.f, ctx.f_3, ctx.f_4, 0);
        input_pos = input_pos + missing;
        input_len = input_len - missing;
    }
    'loop: loop {
        if input_len >=u 64 {
            MD5Transform(ctx.f, ctx.f_3, input, input_pos);
            input_pos = input_pos + 64;
            input_len = input_len - 64;
            br 'loop;
        }
    } /* 'loop */
    if input_len { ctx.f_4.copy(0, input, input_pos, input_len); }
}
fn MD5Final(ctx: &context) -> &string {
    let in_buf: i32;
    let i: i32;
    let len: i64;
    let w: &int_array;
    let buffer: &string;
    let res: &string;
    len = ctx.f_2;
    in_buf = len as i32 & 0x3f;
    buffer = ctx.f_4;
    buffer[in_buf] = 0x80;
    in_buf = in_buf + 1;
    if in_buf >u 56 {
        i = in_buf;
        'loop: loop {
            if i <u 64 { buffer[i] = 0; i = i + 1; br 'loop; }
        } /* 'loop */
        MD5Transform(ctx.f, ctx.f_3, buffer, 0);
        in_buf = 0;
    }
    i = in_buf;
    'loop: loop { buffer[i] = 0; i = i + 1; br_if 'loop i <u 56; }
    len = len << 3;
    buffer[56] = len as i32;
    buffer[57] = (len >>u 8) as i32;
    buffer[58] = (len >>u 16) as i32;
    buffer[59] = (len >>u 24) as i32;
    buffer[60] = (len >>u 32) as i32;
    buffer[61] = (len >>u 40) as i32;
    buffer[62] = (len >>u 48) as i32;
    buffer[63] = (len >>u 56) as i32;
    MD5Transform(ctx.f, ctx.f_3, buffer, 0);
    res = [string|0; 16];
    i = 0;
    w = ctx.f;
    'loop: loop {
        res[i] = w[i >>u 2] >>u (i << 3);
        i = i + 1;
        br_if 'loop i <u 16;
    }
    res;
}
