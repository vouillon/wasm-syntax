#[import = ("hash", "caml_string_hash")]
fn caml_string_hash(&eq, &eq) -> &eq;
#[import = ("string", "caml_string_equal")]
fn caml_string_equal(&eq, &eq) -> &eq;
#[import = ("jslib", "caml_string_of_jsstring")]
fn caml_string_of_jsstring(&eq) -> &eq;
#[import = ("jslib", "caml_jsstring_of_string")]
fn caml_jsstring_of_string(&eq) -> &eq;
#[import = ("jslib", "wrap")]
fn wrap(&?any) -> &eq;
#[import = ("jslib", "unwrap")]
fn unwrap(&eq) -> &?any;
#[import = ("obj", "caml_callback_1")]
fn caml_callback_1(&eq, &eq) -> &eq;
#[import = ("obj", "caml_callback_2")]
fn caml_callback_2(&eq, &eq, &eq) -> &eq;
#[import = ("bindings", "write")]
fn write(i32, &?any);
#[import = ("string", "caml_string_concat")]
fn caml_string_concat(&eq, &eq) -> &eq;
#[import = ("printexc", "caml_format_exception")]
fn caml_format_exception(&eq) -> &eq;
#[import = ("sys", "ocaml_exit")]
tag ocaml_exit(i32);
#[import = ("fail", "ocaml_exception")]
tag ocaml_exception(&eq);
#[import = ("bindings", "exit")]
fn exit(i32);
#[import = ("bindings", "throw")]
fn throw_2(&?extern);
type block = [mut &eq];
type string = [mut i8];
type assoc = { f: &string, f_2: mut &eq, f_3: mut &?assoc };
type assoc_array = [mut &?assoc];
const Named_value_size: i32 = 13;
const named_value_table: &assoc_array =
    [assoc_array|null as &?assoc; Named_value_size];
fn find_named_value(s: &eq, l: &?assoc) -> &?assoc {
    let a: &assoc;
    'tail: do &?assoc {
        'loop: loop {
            a = br_on_cast_fail 'tail &assoc l;
            if caml_string_equal(s, a.f) as &i31 as i32_u { return a; }
            l = a.f_3;
            br 'loop;
        } /* 'loop */
        unreachable;
    } /* 'tail */
}
#[export = "caml_named_value"]
fn caml_named_value(s: &string) -> &?eq {
    'not_found: do {
        return
            (br_on_null 'not_found
                 find_named_value
                     (s,
                      named_value_table
                          [caml_string_hash(0 as &i31, s) as &i31 as i32_s %u
                               Named_value_size])).f_2;
    }
    return null as &?eq;
}
#[export = "caml_register_named_value"]
fn caml_register_named_value(x: &eq, x_2: &eq) -> &eq {
    let h: i32;
    let r: &?assoc;
    h = caml_string_hash(0 as &i31, x) as &i31 as i32_s %u Named_value_size;
    r = named_value_table[h];
    'not_found: do {
        (br_on_null 'not_found find_named_value(x, r)).f_2 = x_2;
        return 0 as &i31;
    }
    named_value_table[h] = {assoc| f: x as &string, f_2: x_2, f_3: r };
    0 as &i31;
}
#[export = "caml_unregister_named_value"]
fn caml_unregister_named_value(name: &eq) -> &eq {
    let h: i32;
    let r: &?assoc;
    let a: &assoc;
    h =
        caml_string_hash(0 as &i31, name) as &i31 as i32_s %u
            Named_value_size;
    r = named_value_table[h];
    'done: do {
        a = br_on_null 'done r;
        r = a.f_3;
        if caml_string_equal(name, a.f) as &i31 as i32_u {
            named_value_table[h] = r;
            br 'done;
        }
        'loop: loop {
            a = br_on_null 'done r;
            if caml_string_equal(name, a.f) as &i31 as i32_u {
                r.f_3 = a.f_3;
                br 'done;
            }
            r = a.f_3;
            br 'loop;
        } /* 'loop */
    } /* 'done */
    0 as &i31;
}
#[export = "caml_global_data"]
let caml_global_data: &block = [block|0 as &i31; 12];
#[export = "caml_register_global"]
fn caml_register_global(x: &eq, v: &eq, x_2: &eq) -> &eq {
    let i: i32;
    i = x as &i31 as i32_u;
    if i <u caml_global_data.length { caml_global_data[i] = v; }
    0 as &i31;
}
#[export = "caml_get_global_data"]
fn caml_get_global_data(x: &eq) -> &eq { caml_global_data; }
type func_2 = fn() -> &eq;
let uncaught_exception: &?extern = null;
fn reraise_exception() -> &eq { throw_2(uncaught_exception); 0 as &i31; }
#[export = "caml_handle_uncaught_exception"]
fn caml_handle_uncaught_exception(exn: &?extern) {
    uncaught_exception = exn;
    caml_main(reraise_exception);
}
#[export = "caml_main"]
fn caml_main(start: &func) {
    let exn: &eq;
    try {
        _ = (start as &func_2)();
    } catch {
        ocaml_exit => { exit(_); }
        ocaml_exception => {
            exn = _;
            'exit: do {
                'not_registered: do {
                    _ =
                        caml_callback_2
                            (br_on_null 'not_registered
                                 caml_named_value(string#"foo"),
                             exn, 0 as &i31);
                    br 'exit;
                }
                'null: do {
                    _ =
                        caml_callback_1
                            (br_on_null 'null caml_named_value(string#"foo"),
                             0 as &i31);
                }
                write
                    (2,
                     unwrap
                         (caml_jsstring_of_string
                              (caml_string_concat
                                   (string#"foo",
                                    caml_string_concat
                                        (caml_format_exception(exn),
                                         string#"\n")))));
            } /* 'exit */
            exit(2);
        }
    }
}
