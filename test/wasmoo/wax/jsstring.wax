#[import = ("wasm:js-string", "compare")]
fn compare_strings(&?extern, &?extern) -> i32
#[import = ("wasm:js-string", "test")]
fn is_string(&?extern) -> i32
#[import = ("wasm:js-string", "hash")]
#[export = "jsstring_hash"]
fn hash_string(i32, &?any) -> i32
#[import = ("wasm:js-string", "fromCharCodeArray")]
fn fromCharCodeArray(&?wstring, i32, i32) -> &extern
#[import = ("wasm:text-decoder", "decodeStringFromUTF8Array")]
fn decodeStringFromUTF8Array(&?string, i32, i32) -> &extern
#[import = ("wasm:text-encoder", "encodeStringToUTF8Array")]
fn encodeStringToUTF8Array(&?extern) -> &string
#[import = ("bindings", "read_string")]
fn read_string(i32) -> &?any
#[import = ("bindings", "read_string_stream")]
fn read_string_stream(i32, i32) -> &?any
#[import = ("bindings", "write_string")]
fn write_string(&?any) -> i32
#[import = ("bindings", "append_string")]
fn append_string(&?any, &?any) -> &?any
type string = [mut i8]
type wstring = [mut i16]
let text_converters_available: i32 = 0;
let string_builtins_available: i32 = 0;
const utf16_buffer_size: i32 = 32768;
let buffer: &wstring = [wstring|0; 0];
fn init() {
    text_converters_available =
        0 !=
            compare_strings
                (decodeStringFromUTF8Array([string|0], 0, 1),
                 decodeStringFromUTF8Array([string|1], 0, 1));
    string_builtins_available =
        0 !=
            compare_strings
                (fromCharCodeArray([wstring|0], 0, 1),
                 fromCharCodeArray([wstring|1], 0, 1));
    if !text_converters_available {
        if string_builtins_available {
            buffer = [wstring|0; utf16_buffer_size];
        }
    }
}
#[export = "jsstring_compare"]
fn jsstring_compare(s: &?any, s': &?any) -> i32 {
    become compare_strings(s as &?extern, s' as &?extern);
}
#[export = "jsstring_test"]
fn jsstring_test(s: &?any) -> i32 { become is_string(s as &?extern); }
#[export = "jsstring_of_substring"]
fn jsstring_of_substring(s: &string, pos: i32, len: i32) -> &?any {
    let i: i32;
    let c: i32;
    if text_converters_available {
        return decodeStringFromUTF8Array(s, pos, pos + len) as &?any;
    }
    'continue: if string_builtins_available & (len <=u utf16_buffer_size) {
        'loop: loop {
            if i <u len {
                c = s[pos + i] as i32_u;
                br_if 'continue c >=u 128;
                buffer[i] = c;
                i = i + 1;
                br 'loop;
            }
        } /* 'loop */
        return fromCharCodeArray(buffer, 0, len) as &?any;
    }
    become jsstring_of_substring_fallback(s, pos, len);
}
#[export = "jsstring_of_string"]
fn jsstring_of_string(s: &string) -> &?any {
    become jsstring_of_substring(s, 0, s.length);
}
#[export = "string_of_jsstring"]
fn string_of_jsstring(s: &?any) -> &string {
    if text_converters_available {
        become encodeStringToUTF8Array(s as &?extern);
    }
    become string_of_jsstring_fallback(s);
}
const buffer_size: i32 = 65536;
fn write_to_buffer(s: &string, pos: i32, len: i32) {
    let i: i32;
    'loop: loop {
        if i <u len {
            i;
            s[pos + i] as i32_u;
            unreachable;
            i = i + 1;
            br 'loop;
        }
    } /* 'loop */
}
fn jsstring_of_substring_fallback(s: &string, pos: i32, len: i32) -> &?any {
    let s': &?any;
    let continued: i32;
    if len <=u buffer_size {
        write_to_buffer(s, pos, len);
        become read_string(len);
    }
    write_to_buffer(s, pos, buffer_size);
    s' = read_string_stream(buffer_size, 1);
    'loop: loop {
        len = len - buffer_size;
        pos = pos + buffer_size;
        continued = len >u buffer_size;
        write_to_buffer(s, pos, continued?buffer_size:len);
        s' =
            append_string
                (s', read_string_stream(continued?buffer_size:len, continued));
        br_if 'loop continued;
    } /* 'loop */
    s';
}
fn read_from_buffer(s: &string, pos: i32, len: i32) {
    let i: i32;
    'loop: loop {
        if i <u len {
            s;
            pos + i;
            i;
            unreachable;
            (_ as &?string)[_] = _;
            i = i + 1;
            br 'loop;
        }
    } /* 'loop */
}
type stack = { s: &string, next: &?stack }
let stack: &?stack = null as &?stack;
fn string_of_jsstring_fallback(s: &?any) -> &string {
    let ofs: i32;
    let len: i32;
    let s': &string;
    let s'': &string;
    let item: &stack;
    len = write_string(s);
    if !stack {
        s' = [string|0; len];
        read_from_buffer(s', 0, len);
        return s';
    }
    'done: {
        item = br_on_null 'done stack;
        'loop: loop {
            ofs = ofs + item.s.length;
            item = br_on_null 'done item.next;
            br 'loop;
        }
    } /* 'done */
    s' = [string|0; len + ofs];
    read_from_buffer(s', ofs, len);
    'done: {
        item = br_on_null 'done stack;
        stack = null as &?stack;
        'loop: loop {
            s'' = item.s;
            len = s''.length;
            ofs = ofs - len;
            s'.copy(ofs, s'', 0, len);
            item = br_on_null 'done item.next;
            br 'loop;
        } /* 'loop */
    } /* 'done */
    s';
}
#[export = "caml_extract_string"]
fn caml_extract_string(len: i32) {
    let s: &string;
    s = [string|0; len];
    read_from_buffer(s, 0, len);
    stack = {stack| s: s, next: stack };
}
