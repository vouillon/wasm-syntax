#[import = ("fail", "caml_failwith")]
fn caml_failwith(&eq);
#[import = ("custom", "custom_compare_id")]
fn custom_compare_id(&eq, &eq, i32) -> i32;
#[import = ("custom", "custom_hash_id")]
fn custom_hash_id(&eq) -> i32;
#[import = ("custom", "custom_next_id")]
fn custom_next_id() -> i64;
type string = [mut i8];
type compare = fn(&eq, &eq, i32) -> i32;
type hash = fn(&eq) -> i32;
type fixed_length = { bsize_32: i32, bsize_64: i32 };
type serialize = fn(&eq, &eq) -> (i32, i32);
type deserialize = fn(&eq) -> (&eq, i32);
type dup = fn(&eq) -> &eq;
type custom_operations = {
    id: &string,
    compare: &?compare,
    compare_ext: &?compare,
    hash: &?hash,
    fixed_length: &?fixed_length,
    serialize: &?serialize,
    deserialize: &?deserialize,
    dup: &?dup
};
type custom = open { f: &custom_operations };
type custom_with_id: custom = open { f: &custom_operations, id: i64 };
const mutex_ops: &custom_operations =
    {custom_operations|
        id: string#"_mutex",
        compare: custom_compare_id,
        compare_ext: null as &?compare,
        hash: custom_hash_id,
        fixed_length: null as &?fixed_length,
        serialize: null as &?serialize,
        deserialize: null as &?deserialize,
        dup: null as &?dup
    };
type mutex: custom_with_id = {
    f: &custom_operations,
    f_2: i64,
    state: mut i32
};
#[export = "caml_ml_mutex_new"]
fn caml_ml_mutex_new(x: &eq) -> &eq {
    {mutex| f: mutex_ops, f_2: custom_next_id(), state: 0 };
}
#[export = "caml_ml_mutex_lock"]
fn caml_ml_mutex_lock(x: &eq) -> &eq {
    let t: &mutex;
    t = x as &mutex;
    if t.state { caml_failwith(string#"foo"); }
    t.state = 1;
    0 as &i31;
}
#[export = "caml_ml_mutex_try_lock"]
fn caml_ml_mutex_try_lock(x: &eq) -> &eq {
    let t: &mutex;
    t = x as &mutex;
    if t.state => &eq { 0 as &i31; } else { t.state = 1; 1 as &i31; }
}
#[export = "caml_ml_mutex_unlock"]
fn caml_ml_mutex_unlock(x: &eq) -> &eq {
    (x as &mutex).state = 0;
    0 as &i31;
}
#[export = "caml_ml_condition_new"]
fn caml_ml_condition_new(x: &eq) -> &eq { 0 as &i31; }
#[export = "caml_ml_condition_wait"]
fn caml_ml_condition_wait(x: &eq, x_2: &eq) -> &eq {
    caml_failwith(string#"foo");
    0 as &i31;
}
#[export = "caml_ml_condition_signal"]
fn caml_ml_condition_signal(x: &eq) -> &eq { 0 as &i31; }
#[export = "caml_ml_condition_broadcast"]
fn caml_ml_condition_broadcast(x: &eq) -> &eq { 0 as &i31; }
