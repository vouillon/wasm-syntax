#[import = ("fail", "caml_bound_error")]
fn caml_bound_error();
#[import = ("fail", "caml_invalid_argument")]
fn caml_invalid_argument(arg: &eq);
type string = [mut i8];
#[export = "caml_string_equal"]
#[export = "caml_bytes_equal"]
fn caml_string_equal(p1: &eq, p2: &eq) -> &eq {
    let s1: &string;
    let s2: &string;
    let len: i32;
    let i: i32;
    if p1 == p2 { return 1 as &i31; }
    s1 = p1 as &string;
    s2 = p2 as &string;
    len = s1.length;
    if len != s2.length { return 0 as &i31; }
    i = 0;
    'loop: loop {
        if i <s len {
            if s1[i] as i32_u != s2[i] as i32_u { return 0 as &i31; }
            i = i + 1;
            br 'loop;
        }
    } /* 'loop */
    1 as &i31;
}
#[export = "caml_string_notequal"]
#[export = "caml_bytes_notequal"]
fn caml_string_notequal(p1: &eq, p2: &eq) -> &eq {
    return !(caml_string_equal(p1, p2) as &i31 as i32_u) as &i31;
}
fn string_compare(p1: &eq, p2: &eq) -> i32 {
    let s1: &string;
    let s2: &string;
    let l1: i32;
    let l2: i32;
    let len: i32;
    let i: i32;
    let c1: i32;
    let c2: i32;
    if p1 == p2 { return 0; }
    s1 = p1 as &string;
    s2 = p2 as &string;
    l1 = s1.length;
    l2 = s2.length;
    len = l1 <=u l2?l1:l2;
    i = 0;
    'loop: loop {
        if i <s len {
            c1 = s1[i] as i32_u;
            c2 = s2[i] as i32_u;
            if c1 <u c2 { return -1; }
            if c1 >u c2 { return 1; }
            i = i + 1;
            br 'loop;
        }
    } /* 'loop */
    if l1 <u l2 { return -1; }
    if l1 >u l2 { return 1; }
    0;
}
#[export = "caml_string_compare"]
#[export = "caml_bytes_compare"]
fn caml_string_compare(x: &eq, x_2: &eq) -> &eq {
    string_compare(x, x_2) as &i31;
}
#[export = "caml_string_lessequal"]
#[export = "caml_bytes_lessequal"]
fn caml_string_lessequal(x: &eq, x_2: &eq) -> &eq {
    (string_compare(x, x_2) <=s 0) as &i31;
}
#[export = "caml_string_lessthan"]
#[export = "caml_bytes_lessthan"]
fn caml_string_lessthan(x: &eq, x_2: &eq) -> &eq {
    (string_compare(x, x_2) <s 0) as &i31;
}
#[export = "caml_string_greaterequal"]
#[export = "caml_bytes_greaterequal"]
fn caml_string_greaterequal(x: &eq, x_2: &eq) -> &eq {
    (string_compare(x, x_2) >=s 0) as &i31;
}
#[export = "caml_string_greaterthan"]
#[export = "caml_bytes_greaterthan"]
fn caml_string_greaterthan(x: &eq, x_2: &eq) -> &eq {
    (string_compare(x, x_2) >s 0) as &i31;
}
#[export = "caml_string_of_bytes"]
#[export = "caml_bytes_of_string"]
fn caml_string_of_bytes(v: &eq) -> &eq { v; }
#[export = "caml_create_bytes"]
fn caml_create_bytes(len: &eq) -> &eq {
    let l: i32;
    l = len as &i31 as i32_s;
    if l <s 0 { caml_invalid_argument(string#"foo"); }
    [string|0; l];
}
#[export = "caml_blit_string"]
#[export = "caml_blit_bytes"]
fn caml_blit_string(v1: &eq, i1: &eq, v2: &eq, i2: &eq, n: &eq) -> &eq {
    (v2 as &string).copy
        (i2 as &i31 as i32_s, v1 as &string, i1 as &i31 as i32_s,
         n as &i31 as i32_s);
    0 as &i31;
}
#[export = "caml_fill_bytes"]
fn caml_fill_bytes(v: &eq, offset: &eq, len: &eq, init: &eq) -> &eq {
    (v as &string).fill
        (offset as &i31 as i32_u, init as &i31 as i32_u, len as &i31 as i32_u);
    0 as &i31;
}
#[export = "caml_bytes_get16"]
#[export = "caml_string_get16"]
fn caml_bytes_get16(v: &eq, i: &eq) -> &eq {
    let s: &string;
    let p: i32;
    s = v as &string;
    p = i as &i31 as i32_s;
    if p <s 0 { caml_bound_error(); }
    if p + 1 >=u s.length { caml_bound_error(); }
    (s[p] as i32_u | s[p + 1] as i32_u << 8) as &i31;
}
#[export = "caml_bytes_get32"]
#[export = "caml_string_get32"]
fn caml_bytes_get32(v: &eq, i: &eq) -> i32 {
    let s: &string;
    let p: i32;
    s = v as &string;
    p = i as &i31 as i32_s;
    if p <s 0 { caml_bound_error(); }
    if p + 3 >=u s.length { caml_bound_error(); }
    s[p] as i32_u | s[p + 1] as i32_u << 8 |
        (s[p + 2] as i32_u << 16 | s[p + 3] as i32_u << 24);
}
#[export = "caml_bytes_get64"]
#[export = "caml_string_get64"]
fn caml_bytes_get64(v: &eq, i: &eq) -> i64 {
    let s: &string;
    let p: i32;
    s = v as &string;
    p = i as &i31 as i32_s;
    if p <s 0 { caml_bound_error(); }
    if p + 7 >=u s.length { caml_bound_error(); }
    s[p] as i32_u as i64_u | s[p + 1] as i32_u as i64_u << 8 |
        (s[p + 2] as i32_u as i64_u << 16 | s[p + 3] as i32_u as i64_u << 24)
        |
        (s[p + 4] as i32_u as i64_u << 32 | s[p + 5] as i32_u as i64_u << 40
             |
             (s[p + 6] as i32_u as i64_u << 48 |
                  s[p + 7] as i32_u as i64_u << 56));
}
#[export = "caml_bytes_set16"]
fn caml_bytes_set16(x: &eq, x_2: &eq, x_3: &eq) -> &eq {
    let s: &string;
    let p: i32;
    let v: i32;
    s = x as &string;
    p = x_2 as &i31 as i32_s;
    v = x_3 as &i31 as i32_s;
    if p <s 0 { caml_bound_error(); }
    if p + 1 >=u s.length { caml_bound_error(); }
    s[p] = v;
    s[p + 1] = v >>u 8;
    0 as &i31;
}
#[export = "caml_bytes_set32"]
fn caml_bytes_set32(x: &eq, x_2: &eq, v: i32) -> &eq {
    let s: &string;
    let p: i32;
    s = x as &string;
    p = x_2 as &i31 as i32_s;
    if p <s 0 { caml_bound_error(); }
    if p + 3 >=u s.length { caml_bound_error(); }
    s[p] = v;
    s[p + 1] = v >>u 8;
    s[p + 2] = v >>u 16;
    s[p + 3] = v >>u 24;
    0 as &i31;
}
#[export = "caml_bytes_set64"]
fn caml_bytes_set64(x: &eq, x_2: &eq, v: i64) -> &eq {
    let s: &string;
    let p: i32;
    s = x as &string;
    p = x_2 as &i31 as i32_s;
    if p <s 0 { caml_bound_error(); }
    if p + 7 >=u s.length { caml_bound_error(); }
    s[p] = v as i32;
    s[p + 1] = (v >>u 8) as i32;
    s[p + 2] = (v >>u 16) as i32;
    s[p + 3] = (v >>u 24) as i32;
    s[p + 4] = (v >>u 32) as i32;
    s[p + 5] = (v >>u 40) as i32;
    s[p + 6] = (v >>u 48) as i32;
    s[p + 7] = (v >>u 56) as i32;
    0 as &i31;
}
#[export = "caml_string_concat"]
fn caml_string_concat(vs1: &eq, vs2: &eq) -> &eq {
    let s1: &string;
    let s2: &string;
    let s: &string;
    let l1: i32;
    let l2: i32;
    s1 = vs1 as &string;
    s2 = vs2 as &string;
    l1 = s1.length;
    l2 = s2.length;
    s = [string|0; l1 + l2];
    s.copy(0, s1, 0, l1);
    s.copy(l1, s2, 0, l2);
    s;
}
