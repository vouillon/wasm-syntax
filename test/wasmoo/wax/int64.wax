#[import = ("ints", "parse_sign_and_base")]
fn parse_sign_and_base(&string) -> (i32, i32, i32, i32)
#[import = ("ints", "parse_digit")]
fn parse_digit(i32) -> i32
#[import = ("ints", "parse_int_format")]
fn parse_int_format(&string) -> (i32, i32, i32, i32, i32)
#[import = ("fail", "caml_failwith")]
fn caml_failwith(&eq)
#[import = ("marshal", "caml_serialize_int_8")]
fn caml_serialize_int_8(&eq, i64)
#[import = ("marshal", "caml_deserialize_int_8")]
fn caml_deserialize_int_8(&eq) -> i64
#[import = ("ints", "lowercase_hex_table")]
const lowercase_hex_table: &chars
#[import = ("ints", "uppercase_hex_table")]
const uppercase_hex_table: &chars
type string = [mut i8]
type compare = fn(&eq, &eq, i32) -> i32
type hash = fn(&eq) -> i32
type fixed_length = { bsize_32: i32, bsize_64: i32 }
type serialize = fn(&eq, &eq) -> (i32, i32)
type deserialize = fn(&eq) -> (&eq, i32)
type dup = fn(&eq) -> &eq
type custom_operations = {
    id: &string,
    compare: &?compare,
    compare_ext: &?compare,
    hash: &?hash,
    fixed_length: &?fixed_length,
    serialize: &?serialize,
    deserialize: &?deserialize,
    dup: &?dup
}
type custom = open { f: &custom_operations }
#[export = "int64_ops"]
const int64_ops: &custom_operations =
    {custom_operations|
        id: string#"_j",
        compare: int64_cmp,
        compare_ext: null as &?compare,
        hash: int64_hash,
        fixed_length: {fixed_length| bsize_32: 8, bsize_64: 8 },
        serialize: int64_serialize,
        deserialize: int64_deserialize,
        dup: int64_dup
    };
type int64: custom = { f: &custom_operations, f_2: i64 }
fn int64_cmp(v1: &eq, v2: &eq, x: i32) -> i32 {
    let i1: i64;
    let i2: i64;
    i1 = (v1 as &int64).f_2;
    i2 = (v2 as &int64).f_2;
    (i1 >s i2) - (i1 <s i2);
}
fn int64_hash(v: &eq) -> i32 {
    let i: i64;
    i = (v as &int64).f_2;
    i as i32 ^ (i >>u 32) as i32;
}
fn int64_serialize(s: &eq, v: &eq) -> (i32, i32) {
    caml_serialize_int_8(s, (v as &int64).f_2);
    8;
    8;
}
fn int64_deserialize(s: &eq) -> (&eq, i32) {
    {int64| f: int64_ops, f_2: caml_deserialize_int_8(s) };
    8;
}
fn int64_dup(v: &eq) -> &eq {
    {int64| f: int64_ops, f_2: (v as &int64).f_2 };
}
#[export = "caml_copy_int64"]
fn caml_copy_int64(i: i64) -> &eq { {int64| f: int64_ops, f_2: i }; }
#[export = "Int64_val"]
fn Int64_val(x: &eq) -> i64 { (x as &int64).f_2; }
#[export = "caml_int64_bswap"]
fn caml_int64_bswap(i: i64) -> i64 {
    rotr(i & 0x000000FF000000FF, 8) | rotr(i & 0x0000FF000000FF00, 24) |
        (rotl(i & 0x00FF000000FF0000, 24) | rotl(i & 0xFF000000FF000000, 8));
}
#[export = "caml_int64_compare"]
fn caml_int64_compare(i1: i64, i2: i64) -> &eq {
    ((i1 >s i2) - (i1 <s i2)) as &i31;
}
const INT64_ERRMSG: &string = string#"Int64.of_string";
#[export = "caml_i64_of_digits"]
fn caml_i64_of_digits
(base: i32, signedness: i32, sign: i32, s: &string, i: i32, errmsg: &string)
-> i64 {
    let len: i32;
    let d: i32;
    let c: i32;
    let res: i64;
    let threshold: i64;
    len = s.length;
    if !len { caml_failwith(errmsg); }
    threshold = -1 /u base as i64_u;
    d = parse_digit(s[i] as i32_u);
    if d >=u base { caml_failwith(errmsg); }
    res = d as i64_u;
    'loop: loop {
        i = i + 1;
        if i <s len {
            c = s[i] as i32_u;
            br_if 'loop c == 95;
            d = parse_digit(c);
            if d >=u base { caml_failwith(errmsg); }
            if res >u threshold { caml_failwith(errmsg); }
            res = res * base as i64_u + d as i64_u;
            if res <u d as i64_u { caml_failwith(errmsg); }
            br 'loop;
        }
    } /* 'loop */
    if signedness {
        if sign >s 0 {
            if res >=u 1 << 63 { caml_failwith(errmsg); }
        } else { if res >u 1 << 63 { caml_failwith(errmsg); } }
    }
    if sign <s 0 { res = 0 - res; }
    res;
}
#[export = "caml_int64_of_string"]
fn caml_int64_of_string(v: &eq) -> &eq {
    let s: &string;
    let i: i32;
    let signedness: i32;
    let sign: i32;
    let base: i32;
    s = v as &string;
    parse_sign_and_base(s);
    base = _;
    sign = _;
    signedness = _;
    i = _;
    become caml_copy_int64
        (caml_i64_of_digits(base, signedness, sign, s, i, INT64_ERRMSG));
}
fn format_int64_default(d: i64) -> &eq {
    let s: &string;
    let negative: i32;
    let i: i32;
    let n: i64;
    if d <s 0 { negative = 1; i = 1; d = 0 - d; }
    n = d;
    'count: loop { i = i + 1; n = n /u 10; br_if 'count n != 0; }
    s = [string|0; i];
    'write: loop {
        i = i - 1;
        s[i] = 48 + (d %u 10) as i32;
        d = d /u 10;
        br_if 'write d != 0;
    }
    if negative { s[0] = 45; }
    s;
}
type chars = [i8]
#[export = "caml_int64_format"]
fn caml_int64_format(x: &eq, x_2: &eq) -> &eq {
    let d: i64;
    let s: &string;
    let sign_style: i32;
    let alternate: i32;
    let signed: i32;
    let base: i64;
    let uppercase: i32;
    let negative: i32;
    let i: i32;
    let n: i64;
    let chars: &chars;
    s = x as &string;
    d = (x_2 as &int64).f_2;
    if s.length == 2 {
        if s[1] as i32_u == 100 { become format_int64_default(d); }
    }
    parse_int_format(s);
    uppercase = _;
    base = _ as i64_u;
    signed = _;
    alternate = _;
    sign_style = _;
    if signed & (d <s 0) { negative = 1; d = 0 - d; }
    n = d;
    'count: loop { i = i + 1; n = n /u base; br_if 'count n != 0; }
    if negative | sign_style { i = i + 1; }
    if alternate {
        if d != 0 {
            if base == 16 { i = i + 2; }
            if base == 8 { i = i + 1; }
        }
    }
    chars = uppercase?uppercase_hex_table:lowercase_hex_table;
    s = [string|0; i];
    'write: loop {
        i = i - 1;
        s[i] = chars[(d %u base) as i32] as i32_u;
        d = d /u base;
        br_if 'write d != 0;
    }
    if negative {
        s[0] = 45;
    } else {
        if sign_style {
            if sign_style == 1 { s[0] = 43; } else { s[0] = 32; }
        }
    }
    if alternate {
        if i { s[0] = 48; if base == 16 { s[1] = uppercase?88:120; } }
    }
    s;
}
