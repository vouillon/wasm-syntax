#[import = ("fail", "caml_failwith")]
fn caml_failwith(&eq)
type block = [mut &eq]
type string = [mut i8]
fn get(a: &eq, i: i32) -> i32 {
    let s: &string;
    s = a as &string;
    i = i + i;
    unreachable;
}
const lex_buffer: i32 = 2;
const lex_buffer_len: i32 = 3;
const lex_start_pos: i32 = 5;
const lex_curr_pos: i32 = 6;
const lex_last_pos: i32 = 7;
const lex_last_action: i32 = 8;
const lex_eof_reached: i32 = 9;
const lex_mem: i32 = 10;
const lex_base: i32 = 1;
const lex_backtrk: i32 = 2;
const lex_default: i32 = 3;
const lex_trans: i32 = 4;
const lex_check: i32 = 5;
const lex_base_code: i32 = 6;
const lex_backtrk_code: i32 = 7;
const lex_default_code: i32 = 8;
const lex_trans_code: i32 = 9;
const lex_check_code: i32 = 10;
const lex_code: i32 = 11;
#[export = "caml_lex_engine"]
fn caml_lex_engine(vtbl: &eq, start_state: &eq, vlexbuf: &eq) -> &eq {
    let tbl: &block;
    let lexbuf: &block;
    let c: i32;
    let state: i32;
    let buffer: &string;
    let vpos: &eq;
    let action: &eq;
    let pos: i32;
    let base: i32;
    let backtrk: i32;
    let lex_base_2: &string;
    let lex_backtrk_2: &string;
    let lex_check_2: &string;
    let lex_check_code_2: &string;
    let lex_trans_2: &string;
    let lex_default_2: &string;
    tbl = vtbl as &block;
    lexbuf = vlexbuf as &block;
    state = start_state as &i31 as i32_s;
    buffer = lexbuf[lex_buffer] as &string;
    if state >=s 0 {
        vpos = lexbuf[lex_curr_pos];
        lexbuf[lex_last_pos] = vpos;
        lexbuf[lex_start_pos] = vpos;
        lexbuf[lex_last_action] = -1 as &i31;
    } else { state = -1 - state; }
    lex_base_2 = tbl[lex_base] as &string;
    lex_backtrk_2 = tbl[lex_backtrk] as &string;
    lex_check_2 = tbl[lex_check] as &string;
    lex_check_code_2 = tbl[lex_check_code] as &string;
    lex_trans_2 = tbl[lex_trans] as &string;
    lex_default_2 = tbl[lex_default] as &string;
    'loop: loop {
        base = get(lex_base_2, state);
        if base <s 0 { return (-1 - base) as &i31; }
        backtrk = get(lex_backtrk_2, state);
        if backtrk >=s 0 {
            lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
            lexbuf[lex_last_action] = backtrk as &i31;
        }
        if
            lexbuf[lex_curr_pos] as &i31 as i32_s >=s
                lexbuf[lex_buffer_len] as &i31 as i32_s
        {
            if lexbuf[lex_eof_reached] == 0 as &i31 {
                return (-1 - state) as &i31;
            } else { c = 256; }
        } else {
            pos = lexbuf[lex_curr_pos] as &i31 as i32_u;
            c = buffer[pos] as i32_u;
            lexbuf[lex_curr_pos] = (pos + 1) as &i31;
        }
        if get(lex_check_2, base + c) == state {
            state = get(lex_trans_2, base + c);
        } else { state = get(lex_default_2, state); }
        if state <s 0 {
            lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
            action = lexbuf[lex_last_action];
            if action == -1 as &i31 { caml_failwith(string#"foo"); }
            return action;
        }
        if c == 256 { lexbuf[lex_eof_reached] = 0 as &i31; }
        br 'loop;
    } /* 'loop */
    unreachable;
}
fn run_mem(s: &string, i: i32, lexbuf: &block, curr_pos: &eq) {
    let dst: i32;
    let src: i32;
    let mem: &block;
    mem = lexbuf[lex_mem] as &block;
    'loop: loop {
        dst = s[i] as i32_u;
        if dst == 0xff { return; }
        src = s[i + 1] as i32_u;
        i = i + 2;
        mem[dst + 1] =
            if src == 0xff => &eq { curr_pos; } else { mem[src + 1]; };
        br 'loop;
    } /* 'loop */
}
fn run_tag(s: &string, i: i32, lexbuf: &block) {
    become run_mem(s, i, lexbuf, -1 as &i31);
}
#[export = "caml_new_lex_engine"]
fn caml_new_lex_engine(vtbl: &eq, start_state: &eq, vlexbuf: &eq) -> &eq {
    let tbl: &block;
    let lexbuf: &block;
    let c: i32;
    let state: i32;
    let pstate: i32;
    let buffer: &string;
    let vpos: &eq;
    let action: &eq;
    let pos: i32;
    let base: i32;
    let backtrk: i32;
    let pc_off: i32;
    let base_code: i32;
    let lex_code_2: &string;
    let lex_base_2: &string;
    let lex_base_code_2: &string;
    let lex_backtrk_2: &string;
    let lex_backtrk_code_2: &string;
    let lex_check_2: &string;
    let lex_check_code_2: &string;
    let lex_trans_2: &string;
    let lex_trans_code_2: &string;
    let lex_default_2: &string;
    let lex_default_code_2: &string;
    tbl = vtbl as &block;
    lexbuf = vlexbuf as &block;
    state = start_state as &i31 as i32_s;
    buffer = lexbuf[lex_buffer] as &string;
    if state >=s 0 {
        vpos = lexbuf[lex_curr_pos];
        lexbuf[lex_last_pos] = vpos;
        lexbuf[lex_start_pos] = vpos;
        lexbuf[lex_last_action] = -1 as &i31;
    } else { state = -1 - state; }
    lex_code_2 = tbl[lex_code] as &string;
    lex_base_2 = tbl[lex_base] as &string;
    lex_base_code_2 = tbl[lex_base_code] as &string;
    lex_backtrk_2 = tbl[lex_backtrk] as &string;
    lex_backtrk_code_2 = tbl[lex_backtrk_code] as &string;
    lex_check_2 = tbl[lex_check] as &string;
    lex_check_code_2 = tbl[lex_check_code] as &string;
    lex_trans_2 = tbl[lex_trans] as &string;
    lex_trans_code_2 = tbl[lex_trans_code] as &string;
    lex_default_2 = tbl[lex_default] as &string;
    lex_default_code_2 = tbl[lex_default_code] as &string;
    'loop: loop {
        base = get(lex_base_2, state);
        if base <s 0 {
            pc_off = get(lex_base_code_2, state);
            run_tag(lex_code_2, pc_off, lexbuf);
            return (-1 - base) as &i31;
        }
        backtrk = get(lex_backtrk_2, state);
        if backtrk >=s 0 {
            pc_off = get(lex_backtrk_code_2, state);
            run_tag(lex_code_2, pc_off, lexbuf);
            lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
            lexbuf[lex_last_action] = backtrk as &i31;
        }
        if
            lexbuf[lex_curr_pos] as &i31 as i32_s >=s
                lexbuf[lex_buffer_len] as &i31 as i32_s
        {
            if lexbuf[lex_eof_reached] == 0 as &i31 {
                return (-1 - state) as &i31;
            } else { c = 256; }
        } else {
            pos = lexbuf[lex_curr_pos] as &i31 as i32_u;
            c = buffer[pos] as i32_u;
            lexbuf[lex_curr_pos] = (pos + 1) as &i31;
        }
        pstate = state;
        if get(lex_check_2, base + c) == state {
            state = get(lex_trans_2, base + c);
        } else { state = get(lex_default_2, state); }
        if state <s 0 {
            lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
            action = lexbuf[lex_last_action];
            if action == -1 as &i31 { caml_failwith(string#"foo"); }
            return action;
        }
        base_code = get(lex_base_code_2, pstate);
        pc_off =
            if get(lex_check_code_2, base_code + c) == pstate => i32 {
                get(lex_trans_code_2, base_code + c);
            } else { get(lex_default_code_2, pstate); };
        run_mem(lex_code_2, pc_off, lexbuf, lexbuf[lex_curr_pos]);
        if c == 256 { lexbuf[lex_eof_reached] = 0 as &i31; }
        br 'loop;
    } /* 'loop */
    unreachable;
}
