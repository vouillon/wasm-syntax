#[import = ("jslib", "unwrap")]
fn unwrap(&eq) -> &?any
#[import = ("bindings", "format_float")]
fn format_float(i32, i32, i32, f64) -> &?any
#[import = ("bindings", "identity")]
fn parse_float(&?any) -> f64
#[import = ("Math", "exp")]
fn exp(f64) -> f64
#[import = ("fail", "caml_failwith")]
fn caml_failwith(&eq)
#[import = ("fail", "caml_invalid_argument")]
fn caml_invalid_argument(&eq)
#[import = ("ints", "lowercase_hex_table")]
const lowercase_hex_table: &chars
#[import = ("jsstring", "jsstring_of_string")]
fn jsstring_of_string(&string) -> &?any
#[import = ("jsstring", "string_of_jsstring")]
fn string_of_jsstring(&?any) -> &string
type float = { f: f64 }
type string = [mut i8]
type block = [mut &eq]
type chars = [i8]
const infinity: &chars = chars#"infinity";
const nan_2: &chars = chars#"nan";
#[export = "Double_val"]
fn Double_val(x: &eq) -> f64 { (x as &float).f; }
#[export = "caml_hexstring_of_float"]
fn caml_hexstring_of_float(x: &eq, x_2: &eq, x_3: &eq) -> &eq {
    let b: i64;
    let prec: i32;
    let style: i32;
    let sign: i32;
    let exp_2: i32;
    let m: i64;
    let i: i32;
    let j: i32;
    let d: i32;
    let txt: &chars;
    let len: i32;
    let s: &string;
    let unit: i64;
    let half: i64;
    let mask: i64;
    let frac: i64;
    prec = x_2 as &i31 as i32_s;
    style = x_3 as &i31 as i32_s;
    b = (x as &float).f.to_bits;
    sign = (b >>u 63) as i32;
    exp_2 = (b >>u 52) as i32 & 0x7FF;
    m = b & (1 << 52) - 1;
    i = sign | (style != 45);
    s =
        'sign: do &string {
            if exp_2 == 0x7FF {
                txt = if !m => &chars { infinity; } else { nan_2; };
                len = txt.length;
                s = [string|0; i + len];
                s.copy(i, txt, 0, len);
                br 'sign s;
            }
            if !exp_2 {
                if m != 0 { exp_2 = -1022; }
            } else { exp_2 = exp_2 - 1023; m = m | 1 << 52; }
            if (prec >=s 0) & (prec <s 13) {
                unit = 1 << (52 - (prec << 2)) as i64_s;
                half = unit >>u 1;
                mask = unit - 1;
                frac = m & mask;
                m = m & (-1 ^ mask);
                if (frac >u half) | (frac == half) & (m & unit != 0) {
                    m = m + unit;
                }
            }
            frac = m << 12;
            j = 0;
            'prec: loop {
                if frac != 0 { j = j + 1; frac = frac << 4; br 'prec; }
            } /* 'prec */
            if prec <s j { prec = j; }
            if exp_2 >=s 0 { d = exp_2; } else { d = 0 - exp_2; }
            j = 0;
            'count: loop { j = j + 1; d = d /u 10; br_if 'count d; }
            len = i + prec + (6 + j);
            if !prec { len = len - 1; }
            s = [string|0; len];
            if exp_2 >=s 0 { d = exp_2; } else { d = 0 - exp_2; }
            'write: loop {
                len = len - 1;
                s[len] = 48 + d %u 10;
                d = d /u 10;
                br_if 'write d;
            }
            s[len - 1] = exp_2 >=s 0?43:45;
            s[i] = 48;
            s[i + 1] = 120;
            s[i + 2] = (m >>u 52) as i32 + 48;
            i = i + 3;
            if prec >s 0 {
                s[i] = 46;
                i = i + 1;
                frac = m << 12;
                'write: loop {
                    s[i] = lowercase_hex_table[(frac >>u 60) as i32] as i32_u;
                    frac = frac << 4;
                    prec = prec - 1;
                    i = i + 1;
                    br_if 'write prec >s 0;
                } /* 'write */
            }
            s[i] = 112;
            s;
        } /* 'sign */;
    if sign { s[0] = 45; } else { if style != 45 { s[0] = style; } }
    s;
}
fn parse_format(s: &string) -> (i32, i32, i32, i32) {
    let i: i32;
    let len: i32;
    let c: i32;
    let sign_style: i32;
    let precision: i32;
    let conversion: i32;
    let uppercase: i32;
    len = s.length;
    i = 1;
    'return: {
        'bad_format: {
            br_if 'bad_format len <u 2;
            br_if 'bad_format s[0] as i32_u != 37;
            c = s[1] as i32_u;
            if c == 43 { sign_style = 1; i = i + 1; }
            if c == 32 { sign_style = 2; i = i + 1; }
            br_if 'bad_format i == len;
            br_if 'bad_format s[i] as i32_u != 46;
            'precision: loop {
                i = i + 1;
                br_if 'bad_format i == len;
                c = s[i] as i32_u;
                if (c >=u 48) & (c <=u 57) {
                    precision = precision * 10 + (c - 48);
                    br 'precision;
                }
            } /* 'precision */
            br_if 'bad_format i + 1 != len;
            uppercase = c <s 96;
            conversion = (c & 0xdf) - 69;
            br_if 'return conversion <=u 2;
        } /* 'bad_format */
        caml_invalid_argument(string#"foo");
    } /* 'return */
    sign_style;
    precision;
    conversion;
    uppercase;
}
const inf_2: &chars = chars#"inf";
#[export = "caml_format_float"]
fn caml_format_float(x: &eq, x_2: &eq) -> &eq {
    let f: f64;
    let b: i64;
    let sign_style: i32;
    let precision: i32;
    let conversion: i32;
    let uppercase: i32;
    let negative: i32;
    let exp_2: i32;
    let m: i64;
    let i: i32;
    let len: i32;
    let c: i32;
    let s: &string;
    let txt: &chars;
    let num: &?any;
    f = (x_2 as &float).f;
    b = f.to_bits;
    parse_format(x as &string);
    uppercase = _;
    conversion = _;
    precision = _;
    sign_style = _;
    negative = (b >>u 63) as i32;
    i = negative | (sign_style != 0);
    s =
        'sign: do &string {
            exp_2 = (b >>u 52) as i32 & 0x7FF;
            if exp_2 == 0x7FF {
                m = b << 12;
                txt =
                    if !m => &chars {
                        inf_2;
                    } else { negative = 0; i = sign_style != 0; nan_2; };
                len = txt.length;
                s = [string|0; i + len];
                s.copy(i, txt, 0, len);
                br 'sign s;
            }
            num = format_float(precision, conversion, i, f.abs);
            s = string_of_jsstring(num);
            br 'sign s;
        } /* 'sign */;
    if negative {
        s[0] = 45;
    } else {
        if sign_style {
            if sign_style == 1 { s[0] = 43; } else { s[0] = 32; }
        }
    }
    if uppercase {
        i = 0;
        len = s.length;
        'uppercase: loop {
            c = s[i] as i32_u;
            if (c >=u 97) & (c <=u 122) { s[i] = c - 32; }
            i = i + 1;
            br_if 'uppercase i <u len;
        } /* 'uppercase */
    }
    s;
}
fn caml_float_of_hex(s: &string, i: i32) -> f64 {
    let len: i32;
    let c: i32;
    let d: i32;
    let m: i64;
    let f: f64;
    let negative: i32;
    let dec_point: i32;
    let exp_2: i32;
    let adj: i32;
    let n_bits: i32;
    let m_bits: i32;
    let x_bits: i32;
    len = s.length;
    dec_point = -1;
    'error: {
        'parse: loop {
            if i <u len {
                c = s[i] as i32_u;
                i = i + 1;
                if c == 46 {
                    br_if 'error dec_point >=s 0;
                    dec_point = n_bits;
                    br 'parse;
                }
                if (c == 80) | (c == 112) {
                    br_if 'error i == len;
                    c = s[i] as i32_u;
                    i = i + 1;
                    if c == 45 {
                        negative = 1;
                        br_if 'error i == len;
                        c = s[i] as i32_u;
                        i = i + 1;
                    }
                    if c == 43 {
                        br_if 'error i == len;
                        c = s[i] as i32_u;
                        i = i + 1;
                    }
                    'overflow: {
                        'parse_exponent: loop {
                            br_if 'error (c <u 48) | (c >u 57);
                            d = c - 48;
                            exp_2 = exp_2 * 10 + d;
                            br_if 'overflow exp_2 <u d;
                            if i != len {
                                c = s[i] as i32_u;
                                i = i + 1;
                                br 'parse_exponent;
                            }
                        } /* 'parse_exponent */
                        if negative {
                            br_if 'overflow exp_2 >u 0x80000000;
                            exp_2 = 0 - exp_2;
                        } else { br_if 'overflow exp_2 >=u 0x80000000; }
                        br 'parse;
                    } /* 'overflow */
                    if negative | !m { return 0.; } else { return inf; }
                }
                if (c >=u 48) & (c <=u 57) {
                    d = c - 48;
                } else {
                    if (c >=u 97) & (c <=u 102) {
                        d = c - 87;
                    } else {
                        if (c >=u 65) & (c <=u 70) {
                            d = c - 55;
                        } else { br 'error; }
                    }
                }
                n_bits = n_bits + 4;
                br_if 'parse !d & !m;
                if m_bits <u 60 {
                    m = (m << 4) + d as i64_u;
                    m_bits = m_bits + 4;
                } else { if d { m = m | 1; } x_bits = x_bits + 4; }
                br 'parse;
            }
        } /* 'parse */
        br_if 'error !n_bits;
        f = m as f64_s;
        adj = x_bits;
        if dec_point >=s 0 { adj = adj + (dec_point - n_bits); }
        if (adj >s 0) & (exp_2 >s 0x7fffffff) {
            exp_2 = 0x7fffffff;
        } else {
            if (adj <s 0) & (exp_2 <s 0x80000000) {
                exp_2 = 0x80000000;
            } else { exp_2 = exp_2 + adj; }
        }
        if exp_2 { f = ldexp(f, exp_2); }
        return f;
    } /* 'error */
    caml_failwith(string#"foo");
    0.;
}
fn on_whitespace(s: &string, i: i32) -> i32 {
    let c: i32;
    c = s[i] as i32_u;
    (c == 32) | (c - 9 <=u 4);
}
#[export = "caml_float_of_string"]
fn caml_float_of_string(x: &eq) -> &eq {
    let s: &string;
    let len: i32;
    let i: i32;
    let j: i32;
    let s': &string;
    let negative: i32;
    let c: i32;
    let f: f64;
    s = x as &string;
    len = s.length;
    'count: loop {
        if i <u len {
            if 95 == s[i] as i32_u { j = j + 1; }
            i = i + 1;
            br 'count;
        }
    } /* 'count */
    if j {
        s' = [string|0; len - j];
        i = 0;
        j = 0;
        'copy: loop {
            if i <u len {
                c = s[i] as i32_u;
                i = i + 1;
                if c != 95 { s'[j] = c; j = j + 1; }
                br 'copy;
            }
        } /* 'copy */
        len = s'.length;
        s = s';
    }
    i = 0;
    'skip_spaces: loop {
        if i <u len {
            if on_whitespace(s, i) { i = i + 1; br 'skip_spaces; }
        }
    } /* 'skip_spaces */
    'error: {
        br_if 'error i == len;
        br_if 'error on_whitespace(s, len - 1);
        c = s[0] as i32_u;
        if c == 45 { negative = 1; i = 1; }
        if c == 43 { i = 1; }
        if i + 2 <u len {
            if s[i] as i32_u == 48 {
                if s[i + 1] as i32_u & 0xdf == 88 {
                    f = caml_float_of_hex(s, i + 2);
                    if negative { f = -f; }
                    return {float| f: f };
                }
            }
        }
        if i + 3 == len {
            c = s[i] as i32_u;
            if c & 0xdf == 78 {
                i = i + 1;
                c = s[i] as i32_u;
                if c & 0xdf == 65 {
                    i = i + 1;
                    c = s[i] as i32_u;
                    if c & 0xdf == 78 { return {float| f: nan }; }
                }
            }
            if c & 0xdf == 73 {
                i = i + 1;
                c = s[i] as i32_u;
                if c & 0xdf == 78 {
                    i = i + 1;
                    c = s[i] as i32_u;
                    if c & 0xdf == 70 {
                        return {float| f: negative?-inf:inf };
                    }
                }
            }
        }
        if i + 8 == len {
            c = s[i] as i32_u;
            if c & 0xdf == 73 {
                i = i + 1;
                c = s[i] as i32_u;
                if c & 0xdf == 78 {
                    i = i + 1;
                    c = s[i] as i32_u;
                    if c & 0xdf == 70 {
                        i = i + 1;
                        c = s[i] as i32_u;
                        if c & 0xdf == 73 {
                            i = i + 1;
                            c = s[i] as i32_u;
                            if c & 0xdf == 78 {
                                i = i + 1;
                                c = s[i] as i32_u;
                                if c & 0xdf == 73 {
                                    i = i + 1;
                                    c = s[i] as i32_u;
                                    if c & 0xdf == 84 {
                                        i = i + 1;
                                        c = s[i] as i32_u;
                                        if c & 0xdf == 89 {
                                            return
                                                {float|
                                                    f: negative?-inf:inf
                                                };
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        f = parse_float(jsstring_of_string(s));
        br_if 'error f != f;
        return {float| f: f };
    } /* 'error */
    caml_failwith(string#"foo");
    return 0 as &i31;
}
#[export = "caml_nextafter_float"]
fn caml_nextafter_float(x: f64, y: f64) -> f64 {
    let i: i64;
    let j: i64;
    if x != x { return x; }
    if y != y { return y; }
    if x == y { return y; }
    if x == 0. => f64 {
        if y >= 0. => f64 { return 0x1p-1074; } else { return -0x1p-1074; }
    } else {
        i = x.to_bits;
        j = y.to_bits;
        if (i <s j) & (i <u j) { i = i + 1; } else { i = i - 1; }
        return i.from_bits;
    }
}
#[export = "caml_classify_float"]
fn caml_classify_float(x: f64) -> &eq {
    let a: f64;
    a = x.abs;
    (if a >= 0x1p-1022 => i32 {
         if a < inf => i32 { 0; } else { 3; }
     } else {
         if a == 0. => i32 {
             2;
         } else { if a == a => i32 { 1; } else { 4; } }
     } as &i31);
}
#[export = "caml_modf_float"]
fn caml_modf_float(x: &eq) -> &eq {
    let x_2: f64;
    let a: f64;
    let i: f64;
    let f: f64;
    x_2 = (x as &float).f;
    a = x_2.abs;
    if a >= 0. {
        if a < inf {
            i = a.floor;
            f = a - i;
            i = copysign(i, x_2);
            f = copysign(f, x_2);
        } else { i = x_2; f = copysign(0., x_2); }
    } else { i = x_2; f = x_2; }
    [block|0 as &i31, {float| f: f }, {float| f: i }];
}
fn ldexp(x: f64, n: i32) -> f64 {
    if n >s 1023 {
        x = x * 0x1p1023;
        n = n - 1023;
        if n >s 1023 {
            x = x * 0x1p1023;
            n = n - 1023;
            if n >s 1023 { n = 1023; }
        }
    } else {
        if n <s -1022 {
            x = x * 0x1p-969;
            n = n + 969;
            if n <s -1022 {
                x = x * 0x1p-969;
                n = n + 969;
                if n <s -1022 { n = -1022; }
            }
        }
    }
    x * (n as i64_s + 0x3ff << 52).from_bits;
}
#[export = "caml_ldexp_float"]
fn caml_ldexp_float(x: f64, i: &eq) -> f64 { ldexp(x, i as &i31 as i32_s); }
fn frexp(x: f64) -> (f64, i32) {
    let y: i64;
    let e: i32;
    let m: f64;
    y = x.to_bits;
    e = 0x7ff & (y >>u 52) as i32;
    if !e {
        if x != 0. {
            frexp(x * 0x1p64);
            e = _;
            m = _;
            return (m, e - 64);
        } else { return (x, 0); }
    } else { if e == 0x7ff { return (x, 0); } }
    (y & 0x800fffffffffffff | 0x3fe0000000000000).from_bits;
    e - 0x3fe;
}
#[export = "caml_frexp_float"]
fn caml_frexp_float(x: &eq) -> &eq {
    let m: f64;
    let e: i32;
    frexp((x as &float).f);
    e = _;
    m = _;
    [block|0 as &i31, {float| f: m }, e as &i31];
}
#[export = "caml_signbit_float"]
fn caml_signbit_float(x: f64) -> &eq { (x.to_bits >>u 63) as i32 as &i31; }
#[export = "caml_erf_float"]
fn erf(x: f64) -> f64 {
    let a1: f64;
    let a2: f64;
    let a3: f64;
    let a4: f64;
    let a5: f64;
    let p: f64;
    let t: f64;
    let y: f64;
    a1 = 0.254829592;
    a2 = -0.284496736;
    a3 = 1.421413741;
    a4 = -1.453152027;
    a5 = 1.061405429;
    p = 0.3275911;
    t = 1. / (1. + p * x.abs);
    y =
        1. -
            ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) *
                (t * exp(-(x * x)));
    copysign(y, x);
}
#[export = "caml_erfc_float"]
fn caml_erfc_float(x: f64) -> f64 { 1. - erf(x); }
#[export = "caml_fma_float"]
fn caml_fma_float(vx: &eq, vy: &eq, vz: &eq) -> &eq {
    let x: f64;
    let y: f64;
    let z: f64;
    let x_2: i64;
    let x_3: i64;
    let x_4: i64;
    let x_5: i64;
    let x_6: i64;
    let x_7: i64;
    let x_8: i32;
    let x_9: i32;
    let x_10: f64;
    let x_11: f64;
    let x_12: f64;
    let x_13: f64;
    let x_14: f64;
    x = (vx as &float).f;
    y = (vy as &float).f;
    z = (vz as &float).f;
    x_6 =
        (x_3 := (x_2 := y.to_bits) >>u 52 & 2047) +
            (x_5 := (x_4 := x.to_bits) >>u 52 & 2047);
    x_7 = z.to_bits;
    'l_2: {
        'l_3: {
            br_if 'l_3 x_3 >u 1993;
            br_if 'l_3 x_5 >u 1993;
            br_if 'l_3 x_6 >u 3016;
            br_if 'l_3 x_7 & 0x7fe0000000000000 >u 0x7c90000000000000;
            x_8 = 0;
            br_if 'l_3 x_6 <=u 1076;
            x_9 = 0;
            br 'l_2;
        } /* 'l_3 */
        x_7 = x_7 >>u 52 & 2047;
        'cont: {
            br_if 'cont x_3 == 2047;
            br_if 'cont x_5 == 2047;
            br_if 'cont x_7 != 2047;
            return {float| f: x + z + y };
        }
        'cont: {
            br_if 'cont y == 0.;
            br_if 'cont x == 0.;
            br_if 'cont z != 0.;
            return {float| f: x * y };
        }
        'cont: {
            'then: {
                br_if 'then x_5 == 2047;
                br_if 'then x_3 == 2047;
                br_if 'then y == 0.;
                br_if 'then x == 0.;
                br_if 'cont x_7 != 2047;
            } /* 'then */
            return {float| f: x * y + z };
        } /* 'cont */
        'cont: { br_if 'cont x_6 <u 3071; return {float| f: x * y }; }
        'cont: {
            br_if 'cont x_6 >u 967;
            y = x_2 ^ x_4 >s -1?0x1p-1074:-0x1p-1074;
            'cont2: { br_if 'cont2 x_7 <u 3; return {float| f: y + z }; }
            return {float| f: (z * 0x1p54 + y) * 0x1p-54 };
        } /* 'cont */
        'l_3: {
            'l_4: {
                'l_5: {
                    br_if 'l_5 x_6 <u 3017;
                    z = x_7 >u 53?z * 0x1p-53:z;
                    x = (x_8 := x_5 >u x_3)?x * 0x1p-53:x;
                    y = x_8?y:y * 0x1p-53;
                    br 'l_4;
                } /* 'l_5 */
                br_if 'l_3 x_7 <u 1994;
                'l_5: {
                    'l_6: {
                        br_if 'l_6 x_6 >u 1129;
                        'l_7: {
                            br_if 'l_7 x_5 <=u x_3;
                            x = x * 0x1p108;
                            br 'l_5;
                        }
                        y = y * 0x1p108;
                        br 'l_5;
                    } /* 'l_6 */
                    'l_6: {
                        br_if 'l_6 x_5 <=u x_3;
                        x = x_5 >u 53?x * 0x1p-53:x;
                        br 'l_5;
                    }
                    y = x_3 >u 53?y * 0x1p-53:y;
                } /* 'l_5 */
                z = z * 0x1p-53;
            } /* 'l_4 */
            x_9 = 0;
            x_8 = 1;
            br 'l_2;
        } /* 'l_3 */
        'l_3: {
            'l_4: {
                br_if 'l_4 x_5 <u 1994;
                y = y * 0x1p53;
                x = x * 0x1p-53;
                br 'l_3;
            }
            'l_4: {
                br_if 'l_4 x_3 <u 1994;
                x = x * 0x1p53;
                y = y * 0x1p-53;
                br 'l_3;
            }
            z = (x_9 := x_7 <u 219)?z * 0x1p108:z;
            x = (x_8 := x_5 >u x_3)?x * 0x1p108:x;
            y = x_8?y:y * 0x1p108;
            x_8 = 0;
            br 'l_2;
        } /* 'l_3 */
        x_8 = 0;
        x_9 = 0;
    } /* 'l_2 */
    'cont: {
        br_if 'cont z != 0.;
        br_if 'cont !((y == 0.) | (x == 0.));
        return {float| f: x * y + z };
    }
    x =
        (x_11 := x - (x_10 := (x_10 := x * 0x8000001.) - (x_10 - x))) *
            (x_13 := y - (x_12 := (x_12 := y * 0x8000001.) - (x_12 - y))) -
            ((x_14 := y * x) - x_10 * x_12 - x_11 * x_12 - x_10 * x_13);
    'l_2: {
        'l_3: { br_if 'l_3 (y := z + x_14) != 0.; br_if 'l_2 x == 0.; }
        'cont: {
            br_if 'cont
                (z :=
                     (x_10 :=
                          x -
                              (x_12 :=
                                   (z :=
                                        (x_10 :=
                                             x_14 - (x_10 := y - z) +
                                                 (z - (y - x_10)))
                                            + x)
                                       - x_10)
                              + (x_10 - (z - x_12)))
                         +
                         ((y :=
                               z - (x_12 := (x := y + z) - y) +
                                   (y - (x - x_12)))
                              - (y := x_10 + y)))
                    == 0.;
            br_if 'cont (x_3 := y.to_bits) as i32 & 1;
            y = (((y < 0.) ^ (z > 0.)?1:-1) + x_3).from_bits;
        }
        y = x + y;
        'cont: { br_if 'cont !x_8; return {float| f: y * 0x1p53 }; }
        y = x_9?y * 0x1p-108:y;
    } /* 'l_2 */
    {float| f: y };
}
#[export = "caml_float_compare"]
fn caml_float_compare(x: f64, y: f64) -> &eq {
    ((x > y) - (x < y) + ((x == x) - (y == y))) as &i31;
}
#[export = "caml_round"]
fn caml_round(x: f64) -> f64 {
    let y: f64;
    if x >= 0. => f64 {
        y = x.floor;
        if x - y >= 0.5 => f64 { y + 1.; } else { y; }
    } else { y = x.ceil; if y - x >= 0.5 => f64 { y - 1.; } else { y; } }
}
