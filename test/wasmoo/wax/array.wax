#[import = ("fail", "caml_invalid_argument")]
fn caml_invalid_argument(&eq)
type block = [mut &eq]
type string = [mut i8]
type float = { f: f64 }
type float_array = [mut f64]
const empty_array: &eq = [block|0 as &i31];
#[export = "caml_make_vect"]
#[export = "caml_array_make"]
fn caml_make_vect(n: &eq, v: &eq) -> &eq {
    let sz: i32;
    let b: &block;
    let f: f64;
    sz = n as &i31 as i32_s;
    if sz <s 0 { caml_invalid_argument(string#"foo"); }
    if !sz { return empty_array; }
    _ =
        'not_float: do &eq {
            f = (br_on_cast_fail 'not_float &float v).f;
            return [float_array|f; sz];
        };
    b = [block|v; sz + 1];
    b[0] = 0 as &i31;
    b;
}
#[export = "caml_floatarray_make"]
fn caml_floatarray_make(n: &eq, v: &eq) -> &eq {
    let sz: i32;
    let f: f64;
    sz = n as &i31 as i32_s;
    if sz <s 0 { caml_invalid_argument(string#"foo"); }
    if !sz { return empty_array; }
    f = (v as &float).f;
    [float_array|f; sz];
}
#[export = "caml_make_float_vect"]
#[export = "caml_floatarray_create"]
#[export = "caml_array_create_float"]
fn caml_floatarray_create(n: &eq) -> &eq {
    let sz: i32;
    sz = n as &i31 as i32_s;
    if sz <s 0 { caml_invalid_argument(string#"foo"); }
    if !sz { return empty_array; }
    [float_array|0.; sz];
}
#[export = "caml_array_of_uniform_array"]
fn caml_array_of_uniform_array(vinit: &eq) -> &eq {
    let init: &block;
    let res: &float_array;
    let size: i32;
    let i: i32;
    init = vinit as &block;
    size = init.length;
    if size != 1 {
        if init[1] is &float {
            size = size - 1;
            res = [float_array|0.; size];
            'loop: loop {
                res[i] = (init[i + 1] as &float).f;
                i = i + 1;
                br_if 'loop i <u size;
            }
            return res;
        }
    }
    return init;
}
#[export = "caml_floatarray_unsafe_get"]
fn caml_floatarray_unsafe_get(a: &eq, i: &eq) -> &eq {
    {float| f: (a as &float_array)[i as &i31 as i32_s] };
}
#[export = "caml_floatarray_unsafe_set"]
fn caml_floatarray_unsafe_set(a: &eq, i: &eq, v: &eq) -> &eq {
    (a as &float_array)[i as &i31 as i32_s] = (v as &float).f;
    0 as &i31;
}
#[export = "caml_array_sub"]
fn caml_array_sub(a: &eq, i: &eq, vlen: &eq) -> &eq {
    let a1: &block;
    let a2: &block;
    let len: i32;
    let fa1: &float_array;
    let fa2: &float_array;
    len = vlen as &i31 as i32_u;
    if !len { return empty_array; }
    _ =
        'not_block: do &eq {
            a1 = br_on_cast_fail 'not_block &block a;
            a2 = [block|0 as &i31; len + 1];
            a2[0] = a1[0];
            a2.copy(1, a1, i as &i31 as i32_u + 1, len);
            return a2;
        } /* 'not_block */;
    fa1 = a as &float_array;
    fa2 = [float_array|0.; len];
    fa2.copy(0, fa1, i as &i31 as i32_u, len);
    fa2;
}
#[export = "caml_floatarray_sub"]
fn caml_floatarray_sub(a: &eq, i: &eq, vlen: &eq) -> &eq {
    let len: i32;
    let fa1: &float_array;
    let fa2: &float_array;
    len = vlen as &i31 as i32_u;
    if !len { return empty_array; }
    fa1 = a as &float_array;
    fa2 = [float_array|0.; len];
    fa2.copy(0, fa1, i as &i31 as i32_u, len);
    fa2;
}
fn caml_floatarray_dup(a: &float_array) -> &eq {
    let a': &float_array;
    let len: i32;
    len = a.length;
    a' = [float_array|0.; len];
    a'.copy(0, a, 0, len);
    a';
}
#[export = "caml_array_append"]
fn caml_array_append(va1: &eq, va2: &eq) -> &eq {
    let a1: &block;
    let a2: &block;
    let a: &block;
    let fa1: &float_array;
    let fa2: &float_array;
    let fa: &float_array;
    let l1: i32;
    let l2: i32;
    _ =
        'a1_not_block: do &eq {
            a1 = br_on_cast_fail 'a1_not_block &block va1;
            _ =
                'a2_not_block: do &eq {
                    a2 = br_on_cast_fail 'a2_not_block &block va2;
                    l1 = a1.length;
                    l2 = a2.length;
                    a = [block|0 as &i31; l1 + l2 - 1];
                    a.copy(1, a1, 1, l1 - 1);
                    a.copy(l1, a2, 1, l2 - 1);
                    return a;
                } /* 'a2_not_block */;
            become caml_floatarray_dup(va2 as &float_array);
        };
    fa1 = va1 as &float_array;
    _ =
        'a2_not_float_array: do &eq {
            fa2 = br_on_cast_fail 'a2_not_float_array &float_array va2;
            l1 = fa1.length;
            l2 = fa2.length;
            fa = [float_array|0.; l1 + l2];
            fa.copy(0, fa1, 0, l1);
            fa.copy(l1, fa2, 0, l2);
            return fa;
        } /* 'a2_not_float_array */;
    become caml_floatarray_dup(fa1);
}
#[export = "caml_floatarray_append"]
fn caml_floatarray_append(va1: &eq, va2: &eq) -> &eq {
    let fa1: &float_array;
    let fa2: &float_array;
    let fa: &float_array;
    let l1: i32;
    let l2: i32;
    fa1 = va1 as &float_array;
    _ =
        'a2_not_float_array: do &eq {
            fa2 = br_on_cast_fail 'a2_not_float_array &float_array va2;
            l1 = fa1.length;
            l2 = fa2.length;
            fa = [float_array|0.; l1 + l2];
            fa.copy(0, fa1, 0, l1);
            fa.copy(l1, fa2, 0, l2);
            return fa;
        } /* 'a2_not_float_array */;
    become caml_floatarray_dup(fa1);
}
#[export = "caml_array_concat"]
fn caml_array_concat(x: &eq) -> &eq {
    let i: i32;
    let len: i32;
    let l: &eq;
    let v: &eq;
    let isfloat: i32;
    let b: &block;
    let a: &block;
    let a': &block;
    let fa: &float_array;
    let fa': &float_array;
    l = x;
    len = 0;
    'compute_length: loop {
        _ =
            'exit: do &eq {
                b = br_on_cast_fail 'exit &block l;
                v = b[1];
                'continue: {
                    _ =
                        'not_block: do &eq {
                            len =
                                len +
                                    ((br_on_cast_fail 'not_block &block v).length
                                         - 1);
                            br 'continue;
                        };
                    len = len + (v as &float_array).length;
                    isfloat = 1;
                }
                l = b[2];
                br 'compute_length;
            } /* 'exit */;
    }
    if isfloat => &eq {
        fa = [float_array|0.; len];
        l = x;
        i = 0;
        'fill: loop {
            _ =
                'exit: do &eq {
                    b = br_on_cast_fail 'exit &block l;
                    l = b[2];
                    _ =
                        'not_float: do &eq {
                            fa' =
                                br_on_cast_fail 'not_float &float_array b[1];
                            len = fa'.length;
                            fa.copy(i, fa', 0, len);
                            i = i + len;
                            br 'fill;
                        } /* 'not_float */;
                    br 'fill;
                };
        }
        fa;
    } else {
        a = [block|0 as &i31; len + 1];
        l = x;
        i = 1;
        'fill: loop {
            _ =
                'exit: do &eq {
                    b = br_on_cast_fail 'exit &block l;
                    a' = b[1] as &block;
                    len = a'.length - 1;
                    a.copy(i, a', 1, len);
                    i = i + len;
                    l = b[2];
                    br 'fill;
                } /* 'exit */;
        }
        a;
    }
}
#[export = "caml_floatarray_blit"]
fn caml_floatarray_blit(a1: &eq, i1: &eq, a2: &eq, i2: &eq, vlen: &eq) -> &eq
{
    let len: i32;
    len = vlen as &i31 as i32_s;
    if len {
        (a2 as &float_array).copy
            (i2 as &i31 as i32_s, a1 as &float_array, i1 as &i31 as i32_s,
             len);
    }
    0 as &i31;
}
#[export = "caml_array_blit"]
fn caml_array_blit(a1: &eq, i1: &eq, a2: &eq, i2: &eq, vlen: &eq) -> &eq {
    let len: i32;
    len = vlen as &i31 as i32_s;
    if len {
        if a1 is &float_array {
            become caml_floatarray_blit(a1, i1, a2, i2, vlen);
        } else {
            (a2 as &block).copy
                (i2 as &i31 as i32_s + 1, a1 as &block,
                 i1 as &i31 as i32_s + 1, len);
        }
    }
    0 as &i31;
}
#[export = "caml_array_fill"]
fn caml_array_fill(a: &eq, i: &eq, vlen: &eq, v: &eq) -> &eq {
    let len: i32;
    len = vlen as &i31 as i32_u;
    'done: if len {
        _ =
            'not_block: do &eq {
                (br_on_cast_fail 'not_block &block a).fill
                    (i as &i31 as i32_u + 1, v, len);
                br 'done;
            };
        (a as &float_array).fill(i as &i31 as i32_u, (v as &float).f, len);
    }
    0 as &i31;
}
#[export = "caml_floatarray_fill"]
fn caml_floatarray_fill(a: &eq, i: &eq, vlen: &eq, v: &eq) -> &eq {
    let len: i32;
    len = vlen as &i31 as i32_u;
    if len {
        (a as &float_array).fill(i as &i31 as i32_u, (v as &float).f, len);
    }
    0 as &i31;
}
