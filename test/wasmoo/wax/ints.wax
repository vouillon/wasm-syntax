#[import = ("fail", "caml_failwith")]
fn caml_failwith(&eq);
#[import = ("fail", "caml_invalid_argument")]
fn caml_invalid_argument(&eq);
type string = [mut i8];
#[export = "caml_format_int"]
fn caml_format_int(x: &eq, x_2: &eq) -> &eq {
    become format_int(x, x_2 as &i31 as i32_s, 1);
}
#[export = "parse_sign_and_base"]
fn parse_sign_and_base(s: &string) -> (i32, i32, i32, i32) {
    let i: i32;
    let len: i32;
    let c: i32;
    let signedness: i32;
    let sign: i32;
    let base: i32;
    i = 0;
    len = s.length;
    signedness = 1;
    sign = 1;
    base = 10;
    if len != 0 {
        c = s[0] as i32_u;
        if c == 45 { sign = -1; i = 1; } else { if c == 43 { i = 1; } }
    }
    if i + 1 <s len {
        if s[i] as i32_u == 48 {
            c = s[i + 1] as i32_u;
            if (c == 88) | (c == 120) {
                base = 16;
                signedness = 0;
                i = i + 2;
            } else {
                if (c == 79) | (c == 111) {
                    base = 8;
                    signedness = 0;
                    i = i + 2;
                } else {
                    if (c == 66) | (c == 98) {
                        base = 2;
                        signedness = 0;
                        i = i + 2;
                    } else {
                        if (c == 85) | (c == 117) {
                            signedness = 0;
                            i = i + 2;
                        }
                    }
                }
            }
        }
    }
    i;
    signedness;
    sign;
    base;
}
#[export = "parse_digit"]
fn parse_digit(c: i32) -> i32 {
    if (c >=u 48) & (c <=u 57) { return c - 48; }
    if (c >=u 65) & (c <=u 90) { return c - 55; }
    if (c >=u 97) & (c <=u 122) { return c - 87; }
    return -1;
}
#[export = "parse_int"]
fn parse_int(v: &eq, nbits: i32, errmsg: &string) -> i32 {
    let s: &string;
    let i: i32;
    let len: i32;
    let d: i32;
    let c: i32;
    let signedness: i32;
    let sign: i32;
    let base: i32;
    let res: i32;
    let threshold: i32;
    s = v as &string;
    len = s.length;
    if !len { caml_failwith(errmsg); }
    parse_sign_and_base(s);
    base = _;
    sign = _;
    signedness = _;
    i = _;
    threshold = -1 /u base;
    if i >=s len { caml_failwith(errmsg); }
    d = parse_digit(s[i] as i32_u);
    if d >=u base { caml_failwith(errmsg); }
    res = d;
    'loop: loop {
        i = i + 1;
        if i <s len {
            c = s[i] as i32_u;
            br_if 'loop c == 95;
            d = parse_digit(c);
            if d >=u base { caml_failwith(errmsg); }
            if res >u threshold { caml_failwith(errmsg); }
            res = res * base + d;
            if res <u d { caml_failwith(errmsg); }
            br 'loop;
        }
    } /* 'loop */
    if signedness {
        threshold = 1 << nbits - 1;
        if sign >s 0 {
            if res >=u threshold { caml_failwith(errmsg); }
        } else { if res >u threshold { caml_failwith(errmsg); } }
    } else {
        if (nbits <u 32) & (res >=u 1 << nbits) { caml_failwith(errmsg); }
    }
    if sign <s 0 { res = 0 - res; }
    res;
}
const INT_ERRMSG: &string = string#"int_of_string";
#[export = "caml_int_of_string"]
fn caml_int_of_string(v: &eq) -> &eq {
    parse_int(v, 31, INT_ERRMSG) as &i31;
}
#[export = "caml_bswap16"]
fn caml_bswap16(x: &eq) -> &eq {
    let x_2: i32;
    x_2 = x as &i31 as i32_s;
    ((x_2 & 0xFF) << 8 | x_2 >>u 8 & 0xFF) as &i31;
}
type chars = [i8];
#[export = "lowercase_hex_table"]
const lowercase_hex_table: &chars = chars#"0123456789abcdef";
#[export = "uppercase_hex_table"]
const uppercase_hex_table: &chars = chars#"0123456789ABCDEF";
fn format_int_default(d: i32) -> &eq {
    let s: &string;
    let negative: i32;
    let i: i32;
    let n: i32;
    if d <s 0 { negative = 1; i = 1; d = 0 - d; }
    n = d;
    'count: loop { i = i + 1; n = n /u 10; br_if 'count n; }
    s = [string|0; i];
    'write: loop {
        i = i - 1;
        s[i] = 48 + d %u 10;
        d = d /u 10;
        br_if 'write d;
    }
    if negative { s[0] = 45; }
    s;
}
#[export = "parse_int_format"]
fn parse_int_format(s: &string) -> (i32, i32, i32, i32, i32) {
    let i: i32;
    let len: i32;
    let c: i32;
    let sign_style: i32;
    let alternate: i32;
    let base: i32;
    let signed: i32;
    let uppercase: i32;
    len = s.length;
    i = 1;
    'return: do {
        'bad_format: do {
            br_if 'bad_format len <u 2;
            br_if 'bad_format s[0] as i32_u != 37;
            c = s[1] as i32_u;
            if c == 43 { sign_style = 1; i = i + 1; }
            if c == 32 { sign_style = 2; i = i + 1; }
            if c == 35 { alternate = 1; i = i + 1; }
            br_if 'bad_format i == len;
            c = s[i] as i32_u;
            if (c == 76) | (c == 108) | (c == 110) {
                i = i + 1;
                br_if 'bad_format i == len;
                c = s[i] as i32_u;
            }
            br_if 'bad_format i + 1 != len;
            if (c == 100) | (c == 105) {
                base = 10;
                signed = 1;
            } else {
                if c == 117 {
                    base = 10;
                } else {
                    if c == 120 {
                        base = 16;
                    } else {
                        if c == 88 {
                            base = 16;
                            uppercase = 1;
                        } else {
                            if c == 111 {
                                base = 8;
                            } else { br 'bad_format; }
                        }
                    }
                }
            }
            br 'return;
        } /* 'bad_format */
        caml_invalid_argument(string#"foo");
    } /* 'return */
    sign_style;
    alternate;
    signed;
    base;
    uppercase;
}
#[export = "format_int"]
fn format_int(x: &eq, d: i32, small: i32) -> &eq {
    let s: &string;
    let sign_style: i32;
    let alternate: i32;
    let signed: i32;
    let base: i32;
    let uppercase: i32;
    let negative: i32;
    let i: i32;
    let n: i32;
    let chars: &chars;
    s = x as &string;
    if s.length == 2 {
        if s[1] as i32_u == 100 { become format_int_default(d); }
    }
    parse_int_format(s);
    uppercase = _;
    base = _;
    signed = _;
    alternate = _;
    sign_style = _;
    if d <s 0 {
        if signed {
            negative = 1;
            d = 0 - d;
        } else { if small { d = d & 0x7fffffff; } }
    }
    n = d;
    'count: loop { i = i + 1; n = n /u base; br_if 'count n; }
    if negative | sign_style { i = i + 1; }
    if alternate {
        if d { if base == 16 { i = i + 2; } if base == 8 { i = i + 1; } }
    }
    chars = uppercase?uppercase_hex_table:lowercase_hex_table;
    s = [string|0; i];
    'write: loop {
        i = i - 1;
        s[i] = chars[d %u base] as i32_u;
        d = d /u base;
        br_if 'write d;
    }
    if negative {
        s[0] = 45;
    } else {
        if sign_style {
            if sign_style == 1 { s[0] = 43; } else { s[0] = 32; }
        }
    }
    if alternate {
        if i { s[0] = 48; if base == 16 { s[1] = uppercase?88:120; } }
    }
    s;
}
