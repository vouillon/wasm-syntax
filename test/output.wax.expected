#[import = ("bindings", "ta_create")] fn ta_create(_: i32, _: i32) -> &extern
#[import = ("bindings", "ta_normalize")]
fn ta_normalize(_: &extern) -> &extern
#[import = ("bindings", "ta_kind")] fn ta_kind(_: &extern) -> i32
#[import = ("bindings", "ta_length")] fn ta_length(_: &extern) -> i32
#[import = ("bindings", "ta_get_f64")]
fn ta_get_f64(_: &extern, _: i32) -> f64
#[import = ("bindings", "ta_get_f32")]
fn ta_get_f32(_: &extern, _: i32) -> f64
#[import = ("bindings", "ta_get_i32")]
fn ta_get_i32(_: &extern, _: i32) -> i32
#[import = ("bindings", "ta_get_i16")]
fn ta_get_i16(_: &extern, _: i32) -> i32
#[import = ("bindings", "ta_get_ui16")]
fn ta_get_ui16(_: &extern, _: i32) -> i32
#[import = ("bindings", "ta_get_i8")] fn ta_get_i8(_: &extern, _: i32) -> i32
#[import = ("bindings", "ta_get_ui8")]
fn ta_get_ui8(_: &extern, _: i32) -> i32
#[import = ("bindings", "ta_get32_ui8")]
fn ta_get32_ui8(_: &extern, _: i32) -> i32
#[import = ("bindings", "ta_get16_ui8")]
fn ta_get16_ui8(_: &extern, _: i32) -> i32
#[import = ("bindings", "ta_set_f64")]
fn ta_set_f64(_: &extern, _: i32, _: f64)
#[import = ("bindings", "ta_set_f32")]
fn ta_set_f32(_: &extern, _: i32, _: f64)
#[import = ("bindings", "ta_set_i32")]
fn ta_set_i32(_: &extern, _: i32, _: i32)
#[import = ("bindings", "ta_set_i16")]
fn ta_set_i16(_: &extern, _: i32, _: &i31)
#[import = ("bindings", "ta_set_ui16")]
fn ta_set_ui16(_: &extern, _: i32, _: &i31)
#[import = ("bindings", "ta_set_i8")]
fn ta_set_i8(_: &extern, _: i32, _: &i31)
#[import = ("bindings", "ta_set_ui8")]
fn ta_set_ui8(_: &extern, _: i32, _: &i31)
#[import = ("bindings", "ta_set16_ui8")]
fn ta_set16_ui8(_: &extern, _: i32, _: &i31)
#[import = ("bindings", "ta_set32_ui8")]
fn ta_set32_ui8(_: &extern, _: i32, _: i32)
#[import = ("bindings", "ta_fill")] fn ta_fill_int(_: &extern, _: i32)
#[import = ("bindings", "ta_fill")] fn ta_fill_float(_: &extern, _: f64)
#[import = ("bindings", "ta_blit")] fn ta_blit(_: &extern, _: &extern)
#[import = ("bindings", "ta_subarray")]
fn ta_subarray(_: &extern, _: i32, _: i32) -> &extern
#[import = ("bindings", "ta_blit_from_string")]
fn ta_blit_from_string(_: &string, _: i32, _: &extern, _: i32, _: i32)
#[import = ("bindings", "ta_blit_to_string")]
fn ta_blit_to_string(_: &extern, _: i32, _: &string, _: i32, _: i32)
#[import = ("fail", "caml_bound_error")] fn caml_bound_error()
#[import = ("fail", "caml_raise_out_of_memory")]
fn caml_raise_out_of_memory()
#[import = ("fail", "caml_invalid_argument")]
fn caml_invalid_argument(_: &eq)
#[import = ("fail", "caml_failwith")] fn caml_failwith(_: &eq)
#[import = ("jslib", "wrap")] fn wrap(_: &?any) -> &eq
#[import = ("jslib", "unwrap")] fn unwrap(_: &eq) -> &?any
#[import = ("int32", "caml_copy_int32")] fn caml_copy_int32(_: i32) -> &eq
#[import = ("int32", "Int32_val")] fn Int32_val(_: &eq) -> i32
#[import = ("int32", "caml_copy_nativeint")]
fn caml_copy_nativeint(_: i32) -> &eq
#[import = ("int64", "caml_copy_int64")] fn caml_copy_int64(_: i64) -> &eq
#[import = ("int64", "Int64_val")] fn Int64_val(_: &eq) -> i64
#[import = ("obj", "double_array_tag")] const double_array_tag: i32
#[import = ("compare", "unordered")] const unordered: i32
#[import = ("hash", "caml_hash_mix_int")]
fn caml_hash_mix_int(_: i32, _: i32) -> i32
#[import = ("hash", "caml_hash_mix_int64")]
fn caml_hash_mix_int64(_: i32, _: i64) -> i32
#[import = ("hash", "caml_hash_mix_double")]
fn caml_hash_mix_double(_: i32, _: f64) -> i32
#[import = ("hash", "caml_hash_mix_float")]
fn caml_hash_mix_float(_: i32, _: f32) -> i32
#[import = ("marshal", "caml_serialize_int_1")]
fn caml_serialize_int_1(_: &eq, _: i32)
#[import = ("marshal", "caml_serialize_int_2")]
fn caml_serialize_int_2(_: &eq, _: i32)
#[import = ("marshal", "caml_serialize_int_4")]
fn caml_serialize_int_4(_: &eq, _: i32)
#[import = ("marshal", "caml_serialize_int_8")]
fn caml_serialize_int_8(_: &eq, _: i64)
#[import = ("marshal", "caml_deserialize_uint_1")]
fn caml_deserialize_uint_1(_: &eq) -> i32
#[import = ("marshal", "caml_deserialize_sint_1")]
fn caml_deserialize_sint_1(_: &eq) -> i32
#[import = ("marshal", "caml_deserialize_uint_2")]
fn caml_deserialize_uint_2(_: &eq) -> i32
#[import = ("marshal", "caml_deserialize_sint_2")]
fn caml_deserialize_sint_2(_: &eq) -> i32
#[import = ("marshal", "caml_deserialize_int_4")]
fn caml_deserialize_int_4(_: &eq) -> i32
#[import = ("marshal", "caml_deserialize_int_8")]
fn caml_deserialize_int_8(_: &eq) -> i64
type block = [mut &eq]
type string = [mut i8]
type float = { f: f64 }
type float_array = [mut f64]
type compare = fn(&eq, &eq, i32) -> i32
type hash = fn(&eq) -> i32
type fixed_length = { bsize_32: i32, bsize_64: i32 }
type serialize = fn(&eq, &eq) -> (i32, i32)
type deserialize = fn(&eq) -> (&eq, i32)
type dup = fn(&eq) -> &eq
type custom_operations = {
    id: &string,
    compare: &?compare,
    compare_ext: &?compare,
    hash: &?hash,
    fixed_length: &?fixed_length,
    serialize: &?serialize,
    deserialize: &?deserialize,
    dup: &?dup
}
type custom = open { f: &custom_operations }
#[export = "bigarray_ops"]
const bigarray_ops: &custom_operations =
    {custom_operations|
        id: string#"_bigarr02" as &string,
        compare: caml_ba_compare,
        compare_ext: null as &?compare,
        hash: bigarray_hash,
        fixed_length: null as &?fixed_length,
        serialize: bigarray_serialize,
        deserialize: bigarray_deserialize,
        dup: null as &?dup
    };
type int_array = [mut i32]
type bigarray: custom = {
    f: &custom_operations,
    ba_data: mut &extern,
    ba_dim: &int_array,
    ba_num_dims: i8,
    ba_kind: i8,
    ba_layout: i8
}
fn bigarray_hash(x: &eq) -> i32 {
    let b: &bigarray;
    let h: i32;
    let len: i32;
    let i: i32;
    let w: i32;
    let data: &extern;
    b = x as &bigarray;
    data = b.ba_data;
    len = ta_length(data);
    'float64: {
        'float32: {
            'int8: {
                'uint8: {
                    'int16: {
                        'uint16: {
                            'int32: {
                                'int64: {
                                    br_table
                                        [ 'float32 'float64 'int8 'uint8
                                            'int16 'uint16 'int32 'int64
                                            'int32 'int32 'float32 'float64
                                            else 'uint8 ]
                                        b.ba_kind as i32_u;
                                }
                                if len >u 32 { len = 32; }
                                'loop_2: loop {
                                    if i <u len {
                                        h =
                                            caml_hash_mix_int64
                                                (h,
                                                 ta_get_i32(data, i) as i64_u
                                                     |
                                                     ta_get_i32(data, i + 1)
                                                         as i64_u << 32);
                                        i = i + 2;
                                        br 'loop_2;
                                    }
                                } /* 'loop_2 */
                                return h;
                            } /* 'int32 */
                            if len >u 64 { len = 64; }
                            'loop_2: loop {
                                if i <u len {
                                    h =
                                        caml_hash_mix_int
                                            (h, ta_get_i32(data, i));
                                    i = i + 1;
                                    br 'loop_2;
                                }
                            } /* 'loop_2 */
                            return h;
                        } /* 'uint16 */
                        if len >u 128 { len = 128; }
                        'loop_2: loop {
                            if i + 2 <=u len {
                                h =
                                    caml_hash_mix_int
                                        (h,
                                         ta_get_ui16(data, i) |
                                             ta_get_ui16(data, i + 1) << 16);
                                i = i + 2;
                                br 'loop_2;
                            }
                        } /* 'loop_2 */
                        if len & 1 {
                            h = caml_hash_mix_int(h, ta_get_ui16(data, i));
                        }
                        return h;
                    } /* 'int16 */
                    if len >u 128 { len = 128; }
                    'loop_2: loop {
                        if i + 2 <=u len {
                            h =
                                caml_hash_mix_int
                                    (h,
                                     ta_get_i16(data, i) |
                                         ta_get_i16(data, i + 1) << 16);
                            i = i + 2;
                            br 'loop_2;
                        }
                    } /* 'loop_2 */
                    if len & 1 {
                        h = caml_hash_mix_int(h, ta_get_i16(data, i));
                    }
                    return h;
                } /* 'uint8 */
                if len >u 256 { len = 256; }
                'loop_2: loop {
                    if i + 4 <=u len {
                        h = caml_hash_mix_int(h, ta_get32_ui8(data, i));
                        i = i + 4;
                        br 'loop_2;
                    }
                } /* 'loop_2 */
                w = 0;
                'l_2: {
                    'l_3: {
                        'l_4: {
                            'l_5: {
                                br_table [ 'l_2 'l_3 'l_4 else 'l_5 ]
                                    (len & 3);
                            }
                            w = ta_get_ui8(data, i + 2) << 16;
                        }
                        w = w | ta_get_ui8(data, i + 1) << 8;
                    } /* 'l_3 */
                    w = w | ta_get_ui8(data, i);
                    h = caml_hash_mix_int(h, w);
                } /* 'l_2 */
                return h;
            } /* 'int8 */
            if len >u 256 { len = 256; }
            'loop_2: loop {
                if i + 4 <=u len {
                    h =
                        caml_hash_mix_int
                            (h,
                             ta_get_i8(data, i) | ta_get_i8(data, i + 1) << 8
                                 |
                                 (ta_get_i8(data, i + 2) << 16 |
                                      ta_get_i8(data, i + 3) << 24));
                    i = i + 4;
                    br 'loop_2;
                }
            } /* 'loop_2 */
            w = 0;
            'l_2: {
                'l_3: {
                    'l_4: {
                        'l_5: {
                            br_table [ 'l_2 'l_3 'l_4 else 'l_5 ] (len & 3);
                        }
                        w = ta_get_i8(data, i + 2) << 16;
                    }
                    w = w | ta_get_i8(data, i + 1) << 8;
                } /* 'l_3 */
                w = w | ta_get_i8(data, i);
                h = caml_hash_mix_int(h, w);
            } /* 'l_2 */
            return h;
        } /* 'float32 */
        if len >u 64 { len = 64; }
        'loop_2: loop {
            if i <u len {
                h = caml_hash_mix_float(h, ta_get_f32(data, i) as f32);
                i = i + 1;
                br 'loop_2;
            }
        } /* 'loop_2 */
        return h;
    } /* 'float64 */
    if len >u 32 { len = 32; }
    'loop_2: loop {
        if i <u len {
            h = caml_hash_mix_double(h, ta_get_f64(data, i));
            i = i + 1;
            br 'loop_2;
        }
    } /* 'loop_2 */
    return h;
}
fn bigarray_serialize(s: &eq, v: &eq) -> (i32, i32) {
    let b: &bigarray;
    let num_dims: i32;
    let dim: &int_array;
    let data: &extern;
    let i: i32;
    let len: i32;
    b = v as &bigarray;
    num_dims = b.ba_num_dims as i32_u;
    dim = b.ba_dim;
    caml_serialize_int_4(s, num_dims);
    caml_serialize_int_4(s, b.ba_kind as i32_u | b.ba_layout as i32_u << 8);
    'loop_2: loop {
        if i <u num_dims {
            len = dim[i];
            if len <u 0xffff {
                caml_serialize_int_2(s, len);
            } else {
                caml_serialize_int_2(s, 0xffff);
                caml_serialize_int_8(s, len as i64_u);
            }
            i = i + 1;
            br 'loop_2;
        }
    } /* 'loop_2 */
    'done: {
        data = b.ba_data;
        len = ta_length(data);
        i = 0;
        'float64: {
            'float32: {
                'int8: {
                    'uint8: {
                        'int16: {
                            'uint16: {
                                'int32: {
                                    'int: {
                                        'int64: {
                                            br_table
                                                [ 'float32 'float64 'int8
                                                    'uint8 'int16 'uint16
                                                    'int32 'int64 'int 'int
                                                    'float32 'float64
                                                    else 'uint8 ]
                                                b.ba_kind as i32_u;
                                        }
                                        'loop_2: loop {
                                            if i <u len {
                                                caml_serialize_int_8
                                                    (s,
                                                     ta_get_i32(data, i)
                                                         as i64_u |
                                                         ta_get_i32
                                                             (data, i + 1)
                                                             as i64_u << 32);
                                                i = i + 2;
                                                br 'loop_2;
                                            }
                                        } /* 'loop_2 */
                                        br 'done;
                                    } /* 'int */
                                    caml_serialize_int_1(s, 0);
                                } /* 'int32 */
                                'loop_2: loop {
                                    if i <u len {
                                        caml_serialize_int_4
                                            (s, ta_get_i32(data, i));
                                        i = i + 1;
                                        br 'loop_2;
                                    }
                                } /* 'loop_2 */
                                br 'done;
                            } /* 'uint16 */
                            'loop_2: loop {
                                if i <u len {
                                    caml_serialize_int_2
                                        (s, ta_get_ui16(data, i));
                                    i = i + 1;
                                    br 'loop_2;
                                }
                            } /* 'loop_2 */
                            br 'done;
                        } /* 'int16 */
                        'loop_2: loop {
                            if i <u len {
                                caml_serialize_int_2(s, ta_get_i16(data, i));
                                i = i + 1;
                                br 'loop_2;
                            }
                        } /* 'loop_2 */
                        br 'done;
                    } /* 'uint8 */
                    'loop_2: loop {
                        if i <u len {
                            caml_serialize_int_1(s, ta_get_ui8(data, i));
                            i = i + 1;
                            br 'loop_2;
                        }
                    } /* 'loop_2 */
                    br 'done;
                } /* 'int8 */
                'loop_2: loop {
                    if i <u len {
                        caml_serialize_int_1(s, ta_get_i8(data, i));
                        i = i + 1;
                        br 'loop_2;
                    }
                } /* 'loop_2 */
                br 'done;
            } /* 'float32 */
            'loop_2: loop {
                if i <u len {
                    caml_serialize_int_4
                        (s, (ta_get_f32(data, i) as f32 as f32).to_bits);
                    i = i + 1;
                    br 'loop_2;
                }
            } /* 'loop_2 */
            br 'done;
        } /* 'float64 */
        'loop_2: loop {
            if i <u len {
                caml_serialize_int_8(s, (ta_get_f64(data, i) as f64).to_bits);
                i = i + 1;
                br 'loop_2;
            }
        } /* 'loop_2 */
    } /* 'done */
    (4 + num_dims) * 4;
    (4 + num_dims) * 8;
}
fn bigarray_deserialize(s: &eq) -> (&eq, i32) {
    let b: &bigarray;
    let num_dims: i32;
    let dim: &int_array;
    let flags: i32;
    let kind: i32;
    let data: &extern;
    let i: i32;
    let len: i32;
    let l: i64;
    num_dims = caml_deserialize_int_4(s);
    flags = caml_deserialize_int_4(s);
    kind = flags & 0xff;
    dim = [int_array| 0; num_dims];
    'loop_2: loop {
        if i <u num_dims {
            len = caml_deserialize_uint_2(s);
            if len == 0xffff { len = caml_deserialize_int_8(s) as i32; }
            dim[i] = len;
            i = i + 1;
            br 'loop_2;
        }
    } /* 'loop_2 */
    b =
        {bigarray|
            f: bigarray_ops,
            ba_data: caml_ba_create_buffer(kind, caml_ba_get_size(dim)),
            ba_dim: dim,
            ba_num_dims: num_dims,
            ba_kind: kind,
            ba_layout: flags >>u 8
        };
    'done: {
        data = b.ba_data;
        len = ta_length(data);
        i = 0;
        'float64: {
            'float32: {
                'int8: {
                    'uint8: {
                        'int16: {
                            'uint16: {
                                'int32: {
                                    'int: {
                                        'int64: {
                                            br_table
                                                [ 'float32 'float64 'int8
                                                    'uint8 'int16 'uint16
                                                    'int32 'int64 'int 'int
                                                    'float32 'float64
                                                    else 'uint8 ]
                                                b.ba_kind as i32_u;
                                        }
                                        'loop_2: loop {
                                            if i <u len {
                                                l = caml_deserialize_int_8(s);
                                                ta_set_i32(data, i, l as i32);
                                                ta_set_i32
                                                    (data, i + 1,
                                                     (l >>u 32) as i32);
                                                i = i + 2;
                                                br 'loop_2;
                                            }
                                        } /* 'loop_2 */
                                        br 'done;
                                    } /* 'int */
                                    if caml_deserialize_uint_1(s) {
                                        caml_failwith(string#"foo");
                                    }
                                } /* 'int32 */
                                'loop_2: loop {
                                    if i <u len {
                                        ta_set_i32
                                            (data, i,
                                             caml_deserialize_int_4(s));
                                        i = i + 1;
                                        br 'loop_2;
                                    }
                                } /* 'loop_2 */
                                br 'done;
                            } /* 'uint16 */
                            'loop_2: loop {
                                if i <u len {
                                    ta_set_ui16
                                        (data, i,
                                         caml_deserialize_uint_2(s) as &i31);
                                    i = i + 1;
                                    br 'loop_2;
                                }
                            } /* 'loop_2 */
                            br 'done;
                        } /* 'int16 */
                        'loop_2: loop {
                            if i <u len {
                                ta_set_i16
                                    (data, i,
                                     caml_deserialize_sint_2(s) as &i31);
                                i = i + 1;
                                br 'loop_2;
                            }
                        } /* 'loop_2 */
                        br 'done;
                    } /* 'uint8 */
                    'loop_2: loop {
                        if i <u len {
                            ta_set_ui8
                                (data, i, caml_deserialize_uint_1(s) as &i31);
                            i = i + 1;
                            br 'loop_2;
                        }
                    } /* 'loop_2 */
                    br 'done;
                } /* 'int8 */
                'loop_2: loop {
                    if i <u len {
                        ta_set_i8
                            (data, i, caml_deserialize_sint_1(s) as &i31);
                        i = i + 1;
                        br 'loop_2;
                    }
                } /* 'loop_2 */
                br 'done;
            } /* 'float32 */
            'loop_2: loop {
                if i <u len {
                    ta_set_f32
                        (data, i,
                         (caml_deserialize_int_4(s) as i32).from_bits as f64);
                    i = i + 1;
                    br 'loop_2;
                }
            } /* 'loop_2 */
            br 'done;
        } /* 'float64 */
        'loop_2: loop {
            if i <u len {
                ta_set_f64
                    (data, i, (caml_deserialize_int_8(s) as i64).from_bits);
                i = i + 1;
                br 'loop_2;
            }
        } /* 'loop_2 */
    } /* 'done */
    b;
    (4 + num_dims) * 4;
}
fn caml_ba_get_size(dim: &int_array) -> i32 {
    let i: i32;
    let n: i32;
    let sz: i64;
    n = dim.length;
    i = 0;
    sz = 1;
    'loop_2: loop {
        if i <u n {
            sz = sz * dim[i] as i64_s;
            if sz != sz as i32 as i64_s { caml_raise_out_of_memory(); }
            i = i + 1;
            br 'loop_2;
        }
    } /* 'loop_2 */
    sz as i32;
}
fn caml_ba_size_per_element(kind: i32) -> i32 {
    (kind == 7) | ((kind == 10) | (kind == 11))?2:1;
}
#[export = "caml_ba_create_buffer"]
fn caml_ba_create_buffer(kind: i32, sz: i32) -> &extern {
    let l: i64;
    l = sz as i64_s * caml_ba_size_per_element(kind) as i64_s;
    if l != l as i32 as i64_s { caml_raise_out_of_memory(); }
    become ta_create(kind, l as i32);
}
const CAML_BA_MAX_NUM_DIMS: i32 = 16;
#[export = "caml_ba_create"]
fn caml_ba_create(vkind: &eq, layout: &eq, d: &eq) -> &eq {
    let vdim: &block;
    let dim: &int_array;
    let kind: i32;
    let num_dims: i32;
    let i: i32;
    let n: i32;
    kind = vkind as &i31 as i32_s;
    vdim = d as &block;
    num_dims = vdim.length - 1;
    if num_dims >u CAML_BA_MAX_NUM_DIMS {
        caml_invalid_argument(string#"foo");
    }
    dim = [int_array| 0; num_dims];
    i = 0;
    'loop_2: loop {
        if i <u num_dims {
            n = vdim[i + 1] as &i31 as i32_s;
            if n <s 0 { caml_invalid_argument(string#"foo"); }
            dim[i] = n;
            i = i + 1;
            br 'loop_2;
        }
    } /* 'loop_2 */
    {bigarray|
        f: bigarray_ops,
        ba_data: caml_ba_create_buffer(kind, caml_ba_get_size(dim)),
        ba_dim: dim,
        ba_num_dims: num_dims,
        ba_kind: kind,
        ba_layout: layout as &i31 as i32_s
    };
}
#[export = "caml_ba_from_typed_array"]
fn caml_ba_from_typed_array(x: &eq) -> &eq {
    let data: &extern;
    let kind: i32;
    let len: i32;
    data = ta_normalize((unwrap(x) as &?extern)!);
    kind = ta_kind(data);
    if kind <s 0 { caml_invalid_argument(string#"foo"); }
    if kind == 13 { kind = 3; }
    len = ta_length(data);
    if len <s 0 { caml_invalid_argument(string#"foo"); }
    {bigarray|
        f: bigarray_ops,
        ba_data: data,
        ba_dim: [int_array| len],
        ba_num_dims: 1,
        ba_kind: kind,
        ba_layout: 0
    };
}
#[export = "caml_ba_to_typed_array"]
fn caml_ba_to_typed_array(x: &eq) -> &eq {
    wrap((x as &bigarray).ba_data as &?any);
}
fn caml_ba_get_at_offset(ba: &bigarray, i: i32) -> &eq {
    let data: &extern;
    data = ba.ba_data;
    'float32: {
        'float64: {
            'int8: {
                'uint8: {
                    'int16: {
                        'uint16: {
                            'int32: {
                                'int64: {
                                    'int: {
                                        'nativeint: {
                                            'complex32: {
                                                'complex64: {
                                                    br_table
                                                        [ 'float32 'float64
                                                            'int8 'uint8
                                                            'int16 'uint16
                                                            'int32 'int64
                                                            'int 'nativeint
                                                            'complex32
                                                            'complex64
                                                            else 'uint8 ]
                                                        ba.ba_kind as i32_u;
                                                }
                                                i = i << 1;
                                                return
                                                    [float_array|
                                                        ta_get_f64(data, i),
                                                        ta_get_f64
                                                            (data, i + 1)];
                                            } /* 'complex32 */
                                            i = i << 1;
                                            return
                                                [float_array|
                                                    ta_get_f32(data, i),
                                                    ta_get_f32(data, i + 1)];
                                        } /* 'nativeint */
                                        become caml_copy_nativeint
                                            (ta_get_i32(data, i));
                                    } /* 'int */
                                    return ta_get_i32(data, i) as &i31;
                                } /* 'int64 */
                                i = i << 1;
                                become caml_copy_int64
                                    (ta_get_i32(data, i) as i64_u |
                                         ta_get_i32(data, i + 1) as i64_u <<
                                             32);
                            } /* 'int32 */
                            become caml_copy_int32(ta_get_i32(data, i));
                        } /* 'uint16 */
                        return ta_get_ui16(data, i) as &i31;
                    } /* 'int16 */
                    return ta_get_i16(data, i) as &i31;
                } /* 'uint8 */
                return ta_get_ui8(data, i) as &i31;
            } /* 'int8 */
            return ta_get_i8(data, i) as &i31;
        } /* 'float64 */
        return {float| f: ta_get_f64(data, i) };
    } /* 'float32 */
    return {float| f: ta_get_f32(data, i) };
}
fn caml_ba_set_at_offset(ba: &bigarray, i: i32, v: &eq) {
    let data: &extern;
    let b: &float_array;
    let l: i64;
    data = ba.ba_data;
    'float32: {
        'float64: {
            'int8: {
                'uint8: {
                    'int16: {
                        'uint16: {
                            'int32: {
                                'int64: {
                                    'int: {
                                        'nativeint: {
                                            'complex32: {
                                                'complex64: {
                                                    br_table
                                                        [ 'float32 'float64
                                                            'int8 'uint8
                                                            'int16 'uint16
                                                            'int32 'int64
                                                            'int 'nativeint
                                                            'complex32
                                                            'complex64
                                                            else 'uint8 ]
                                                        ba.ba_kind as i32_u;
                                                }
                                                i = i << 1;
                                                b = v as &float_array;
                                                ta_set_f64(data, i, b[0]);
                                                ta_set_f64(data, i + 1, b[1]);
                                                return;
                                            } /* 'complex32 */
                                            i = i << 1;
                                            b = v as &float_array;
                                            ta_set_f32(data, i, b[0]);
                                            ta_set_f32(data, i + 1, b[1]);
                                            return;
                                        } /* 'nativeint */
                                        ta_set_i32(data, i, Int32_val(v));
                                        return;
                                    } /* 'int */
                                    ta_set_i32(data, i, v as &i31 as i32_s);
                                    return;
                                } /* 'int64 */
                                i = i << 1;
                                l = Int64_val(v);
                                ta_set_i32(data, i, l as i32);
                                ta_set_i32(data, i + 1, (l >>u 32) as i32);
                                return;
                            } /* 'int32 */
                            ta_set_i32(data, i, Int32_val(v));
                            return;
                        } /* 'uint16 */
                        ta_set_ui16(data, i, v as &i31);
                        return;
                    } /* 'int16 */
                    ta_set_i16(data, i, v as &i31);
                    return;
                } /* 'uint8 */
                ta_set_ui8(data, i, v as &i31);
                return;
            } /* 'int8 */
            ta_set_i8(data, i, v as &i31);
            return;
        } /* 'float64 */
        ta_set_f64(data, i, (v as &float).f);
        return;
    } /* 'float32 */
    ta_set_f32(data, i, (v as &float).f);
    return;
}
#[export = "caml_ba_dim"]
fn caml_ba_dim(x: &eq, x_2: &eq) -> &eq {
    let dim: &int_array;
    let i: i32;
    dim = (x as &bigarray).ba_dim;
    i = x_2 as &i31 as i32_s;
    if i >=u dim.length { caml_invalid_argument(string#"foo"); }
    dim[i] as &i31;
}
#[export = "caml_ba_dim_1"]
fn caml_ba_dim_1(x: &eq) -> &eq { become caml_ba_dim(x, 0 as &i31); }
#[export = "caml_ba_get_1"]
fn caml_ba_get_1(x: &eq, x_2: &eq) -> &eq {
    let ba: &bigarray;
    let i: i32;
    ba = x as &bigarray;
    i = x_2 as &i31 as i32_u;
    if ba.ba_layout as i32_u { i = i - 1; }
    if i >=u ba.ba_dim[0] { caml_bound_error(); }
    become caml_ba_get_at_offset(ba, i);
}
#[export = "caml_ba_set_1"]
fn caml_ba_set_1(x: &eq, x_2: &eq, v: &eq) -> &eq {
    let ba: &bigarray;
    let i: i32;
    ba = x as &bigarray;
    i = x_2 as &i31 as i32_u;
    if ba.ba_layout as i32_u { i = i - 1; }
    if i >=u ba.ba_dim[0] { caml_bound_error(); }
    caml_ba_set_at_offset(ba, i, v);
    0 as &i31;
}
#[export = "caml_ba_get_2"]
fn caml_ba_get_2(vba: &eq, vi: &eq, vj: &eq) -> &eq {
    let ba: &bigarray;
    let i: i32;
    let j: i32;
    let offset: i32;
    let dim: &int_array;
    ba = vba as &bigarray;
    i = vi as &i31 as i32_u;
    j = vj as &i31 as i32_u;
    dim = ba.ba_dim;
    if ba.ba_layout as i32_u {
        i = i - 1;
        j = j - 1;
        offset = j * dim[0] + i;
    } else { offset = i * dim[1] + j; }
    if (i >=u dim[0]) | (j >=u dim[1]) { caml_bound_error(); }
    become caml_ba_get_at_offset(ba, offset);
}
#[export = "caml_ba_set_2"]
fn caml_ba_set_2(vba: &eq, vi: &eq, vj: &eq, v: &eq) -> &eq {
    let ba: &bigarray;
    let i: i32;
    let j: i32;
    let offset: i32;
    let dim: &int_array;
    ba = vba as &bigarray;
    i = vi as &i31 as i32_u;
    j = vj as &i31 as i32_u;
    dim = ba.ba_dim;
    if ba.ba_layout as i32_u {
        i = i - 1;
        j = j - 1;
        offset = j * dim[0] + i;
    } else { offset = i * dim[1] + j; }
    if (i >=u dim[0]) | (j >=u dim[1]) { caml_bound_error(); }
    caml_ba_set_at_offset(ba, offset, v);
    0 as &i31;
}
#[export = "caml_ba_dim_2"]
fn caml_ba_dim_2(x: &eq) -> &eq { become caml_ba_dim(x, 1 as &i31); }
#[export = "caml_ba_get_3"]
fn caml_ba_get_3(vba: &eq, vi: &eq, vj: &eq, vk: &eq) -> &eq {
    let ba: &bigarray;
    let i: i32;
    let j: i32;
    let k: i32;
    let offset: i32;
    let dim: &int_array;
    ba = vba as &bigarray;
    i = vi as &i31 as i32_u;
    j = vj as &i31 as i32_u;
    k = vk as &i31 as i32_u;
    dim = ba.ba_dim;
    if ba.ba_layout as i32_u {
        i = i - 1;
        j = j - 1;
        k = k - 1;
        offset = (k * dim[1] + j) * dim[0] + i;
    } else { offset = (i * dim[1] + j) * dim[2] + k; }
    if (i >=u dim[0]) | ((j >=u dim[1]) | (k >=u dim[2])) {
        caml_bound_error();
    }
    become caml_ba_get_at_offset(ba, offset);
}
#[export = "caml_ba_set_3"]
fn caml_ba_set_3(vba: &eq, vi: &eq, vj: &eq, vk: &eq, v: &eq) -> &eq {
    let ba: &bigarray;
    let i: i32;
    let j: i32;
    let k: i32;
    let offset: i32;
    let dim: &int_array;
    ba = vba as &bigarray;
    i = vi as &i31 as i32_u;
    j = vj as &i31 as i32_u;
    k = vk as &i31 as i32_u;
    dim = ba.ba_dim;
    if ba.ba_layout as i32_u {
        i = i - 1;
        j = j - 1;
        k = k - 1;
        offset = (k * dim[1] + j) * dim[0] + i;
    } else { offset = (i * dim[1] + j) * dim[2] + k; }
    if (i >=u dim[0]) | ((j >=u dim[1]) | (k >=u dim[2])) {
        caml_bound_error();
    }
    caml_ba_set_at_offset(ba, offset, v);
    0 as &i31;
}
#[export = "caml_ba_dim_3"]
fn caml_ba_dim_3(x: &eq) -> &eq { become caml_ba_dim(x, 2 as &i31); }
fn caml_ba_offset(b: &bigarray, index: &int_array) -> i32 {
    let dim: &int_array;
    let num_dims: i32;
    let idx: i32;
    let offset: i32;
    let i: i32;
    let l: i32;
    dim = b.ba_dim;
    if b.ba_layout as i32_u {
        i = b.ba_num_dims as i32_u - 1;
        'loop_2: loop {
            if i >=s 0 {
                idx = index[i] - 1;
                l = dim[i];
                if idx >=u l { caml_bound_error(); }
                offset = offset * l + idx;
                i = i - 1;
                br 'loop_2;
            }
        } /* 'loop_2 */
    } else {
        num_dims = b.ba_num_dims as i32_u;
        'loop_2: loop {
            if i <s num_dims {
                idx = index[i];
                l = dim[i];
                if idx >=u l { caml_bound_error(); }
                offset = offset * l + idx;
                i = i + 1;
                br 'loop_2;
            }
        } /* 'loop_2 */
    }
    offset;
}
fn caml_ba_offset'(b: &bigarray, index: &block) -> i32 {
    let dim: &int_array;
    let num_dims: i32;
    let idx: i32;
    let offset: i32;
    let i: i32;
    let l: i32;
    dim = b.ba_dim;
    if b.ba_layout as i32_u {
        i = b.ba_num_dims as i32_u - 1;
        'loop_2: loop {
            if i >=s 0 {
                idx = index[i + 1] as &i31 as i32_s - 1;
                l = dim[i];
                if idx >=u l { caml_bound_error(); }
                offset = offset * l + idx;
                i = i - 1;
                br 'loop_2;
            }
        } /* 'loop_2 */
    } else {
        num_dims = b.ba_num_dims as i32_u;
        'loop_2: loop {
            if i <s num_dims {
                idx = index[i + 1] as &i31 as i32_s;
                l = dim[i];
                if idx >=u l { caml_bound_error(); }
                offset = offset * l + idx;
                i = i + 1;
                br 'loop_2;
            }
        } /* 'loop_2 */
    }
    offset;
}
#[export = "caml_ba_get_generic"]
fn caml_ba_get_generic(vba: &eq, index: &eq) -> &eq {
    let ba: &bigarray;
    ba = vba as &bigarray;
    become caml_ba_get_at_offset(ba, caml_ba_offset'(ba, index as &block));
}
#[export = "caml_ba_set_generic"]
fn caml_ba_set_generic(vba: &eq, index: &eq, v: &eq) -> &eq {
    let ba: &bigarray;
    ba = vba as &bigarray;
    caml_ba_set_at_offset(ba, caml_ba_offset'(ba, index as &block), v);
    0 as &i31;
}
#[export = "caml_ba_slice"]
fn caml_ba_slice(vb: &eq, vind: &eq) -> &eq {
    let b: &bigarray;
    let ind: &block;
    let index: &int_array;
    let sub_dim: &int_array;
    let num_inds: i32;
    let num_dims: i32;
    let i: i32;
    let idx: i32;
    let mul: i32;
    let offset: i32;
    let size: i32;
    let sub_data: &extern;
    b = vb as &bigarray;
    ind = vind as &block;
    num_inds = ind.length - 1;
    num_dims = b.ba_num_dims as i32_u;
    if num_inds >u b.ba_num_dims as i32_u {
        caml_invalid_argument(string#"foo");
    }
    sub_dim = [int_array| 0; num_dims - num_inds];
    if b.ba_layout as i32_u {
        index = [int_array| 1; num_dims];
        'loop_2: loop {
            if i <u num_inds {
                index[num_dims + i - num_inds] = ind[i + 1] as &i31 as i32_u;
                i = i + 1;
                br 'loop_2;
            }
        } /* 'loop_2 */
        offset = caml_ba_offset(b, index);
        sub_dim.copy(0, b.ba_dim, 0, num_dims - num_inds);
    } else {
        index = [int_array| 0; num_dims];
        'loop_2: loop {
            if i <u num_inds {
                index[i] = ind[i + 1] as &i31 as i32_u;
                i = i + 1;
                br 'loop_2;
            }
        } /* 'loop_2 */
        offset = caml_ba_offset(b, index);
        sub_dim.copy(0, b.ba_dim, num_inds, num_dims - num_inds);
    }
    mul = caml_ba_size_per_element(b.ba_kind as i32_u);
    size = caml_ba_get_size(sub_dim);
    sub_data = ta_subarray(b.ba_data, offset * mul, (offset + size) * mul);
    {bigarray|
        f: bigarray_ops,
        ba_data: sub_data,
        ba_dim: sub_dim,
        ba_num_dims: sub_dim.length,
        ba_kind: b.ba_kind as i32_u,
        ba_layout: b.ba_layout as i32_u
    };
}
#[export = "caml_ba_sub"]
fn caml_ba_sub(vba: &eq, vofs: &eq, vlen: &eq) -> &eq {
    let ba: &bigarray;
    let ofs: i32;
    let len: i32;
    let changed_dim: i32;
    let mul: i32;
    let i: i32;
    let num_dims: i32;
    let dim: &int_array;
    let new_dim: &int_array;
    let new_data: &extern;
    ba = vba as &bigarray;
    ofs = vofs as &i31 as i32_s;
    len = vlen as &i31 as i32_s;
    num_dims = ba.ba_num_dims as i32_u;
    dim = ba.ba_dim;
    mul = 1;
    if ba.ba_layout as i32_u {
        changed_dim = num_dims - 1;
        ofs = ofs - 1;
        i = 0;
        'loop_2: loop {
            if i <u changed_dim {
                mul = mul * dim[i];
                i = i + 1;
                br 'loop_2;
            }
        } /* 'loop_2 */
    } else {
        changed_dim = 0;
        i = 1;
        'loop_2: loop {
            if i <u num_dims { mul = mul * dim[i]; i = i + 1; br 'loop_2; }
        } /* 'loop_2 */
    }
    if (ofs <s 0) | (len <s 0) | (ofs + len >s dim[changed_dim]) {
        caml_invalid_argument(string#"foo");
    }
    new_dim = [int_array| 0; num_dims];
    new_dim.copy(0, dim, 0, num_dims);
    new_dim[changed_dim] = len;
    mul = mul * caml_ba_size_per_element(ba.ba_kind as i32_u);
    new_data = ta_subarray(ba.ba_data, ofs * mul, (ofs + len) * mul);
    {bigarray|
        f: bigarray_ops,
        ba_data: new_data,
        ba_dim: new_dim,
        ba_num_dims: num_dims,
        ba_kind: ba.ba_kind as i32_u,
        ba_layout: ba.ba_layout as i32_u
    };
}
#[export = "caml_ba_fill"]
fn caml_ba_fill(vba: &eq, v: &eq) -> &eq {
    let ba: &bigarray;
    let data: &extern;
    let l: i64;
    let i: i32;
    let len: i32;
    let i1: i32;
    let i2: i32;
    let f1: f64;
    let f2: f64;
    let b: &float_array;
    ba = vba as &bigarray;
    data = ba.ba_data;
    'float: {
        'int: {
            'int32: {
                'int64: {
                    'complex32: {
                        'complex64: {
                            br_table
                                [ 'float 'float 'int 'int 'int 'int 'int32
                                    'int64 'int 'int32 'complex32 'complex64
                                    else 'int ]
                                ba.ba_kind as i32_u;
                        }
                        len = ta_length(data);
                        b = v as &float_array;
                        f1 = b[0];
                        f2 = b[1];
                        'loop_2: loop {
                            if i <u len {
                                ta_set_f64(data, i, f1);
                                ta_set_f64(data, i + 1, f2);
                                i = i + 2;
                                br 'loop_2;
                            }
                        } /* 'loop_2 */
                        return 0 as &i31;
                    } /* 'complex32 */
                    len = ta_length(data);
                    b = v as &float_array;
                    f1 = b[0];
                    f2 = b[1];
                    'loop_2: loop {
                        if i <u len {
                            ta_set_f32(data, i, f1);
                            ta_set_f32(data, i + 1, f2);
                            i = i + 2;
                            br 'loop_2;
                        }
                    } /* 'loop_2 */
                    return 0 as &i31;
                } /* 'int64 */
                len = ta_length(data);
                l = Int64_val(v);
                i1 = l as i32;
                i2 = (l >>u 32) as i32;
                'loop_2: loop {
                    if i <u len {
                        ta_set_i32(data, i, i1);
                        ta_set_i32(data, i + 1, i2);
                        i = i + 2;
                        br 'loop_2;
                    }
                } /* 'loop_2 */
                return 0 as &i31;
            } /* 'int32 */
            ta_fill_int(data, Int32_val(v));
            return 0 as &i31;
        } /* 'int */
        ta_fill_int(data, v as &i31 as i32_s);
        return 0 as &i31;
    } /* 'float */
    ta_fill_float(data, (v as &float).f);
    return 0 as &i31;
}
#[export = "caml_ba_blit"]
fn caml_ba_blit(vsrc: &eq, vdst: &eq) -> &eq {
    let src: &bigarray;
    let dst: &bigarray;
    let sdim: &int_array;
    let ddim: &int_array;
    let i: i32;
    let len: i32;
    src = vsrc as &bigarray;
    dst = vdst as &bigarray;
    len = dst.ba_num_dims as i32_u;
    if len != src.ba_num_dims as i32_u {
        caml_invalid_argument(string#"foo");
    }
    sdim = src.ba_dim;
    ddim = dst.ba_dim;
    'loop_2: loop {
        if i <s len {
            if sdim[i] != ddim[i] { caml_invalid_argument(string#"foo"); }
            i = i + 1;
            br 'loop_2;
        }
    } /* 'loop_2 */
    ta_blit(src.ba_data, dst.ba_data);
    0 as &i31;
}
#[export = "caml_ba_reshape"]
fn caml_ba_reshape(vb: &eq, vd: &eq) -> &eq {
    let vdim: &block;
    let num_dims: i32;
    let num_elts: i64;
    let i: i32;
    let d: i32;
    let b: &bigarray;
    let dim: &int_array;
    vdim = vd as &block;
    num_dims = vdim.length - 1;
    b = vb as &bigarray;
    if num_dims >u CAML_BA_MAX_NUM_DIMS {
        caml_invalid_argument(string#"foo");
    }
    num_elts = 1;
    dim = [int_array| 0; num_dims];
    'loop_2: loop {
        if i <u num_dims {
            d = vdim[i + 1] as &i31 as i32_s;
            if d <s 0 { caml_invalid_argument(string#"foo"); }
            dim[i] = d;
            num_elts = num_elts * d as i64_s;
            if num_elts != num_elts as i32 as i64_s {
                caml_raise_out_of_memory();
            }
            i = i + 1;
            br 'loop_2;
        }
    } /* 'loop_2 */
    if num_elts as i32 != caml_ba_get_size(b.ba_dim) {
        caml_invalid_argument(string#"foo");
    }
    {bigarray|
        f: bigarray_ops,
        ba_data: b.ba_data,
        ba_dim: dim,
        ba_num_dims: num_dims,
        ba_kind: b.ba_kind as i32_u,
        ba_layout: b.ba_layout as i32_u
    };
}
#[export = "caml_ba_change_layout"]
fn caml_ba_change_layout(vb: &eq, vlayout: &eq) -> &eq {
    let b: &bigarray;
    let layout: i32;
    let num_dims: i32;
    let i: i32;
    let dim: &int_array;
    let new_dim: &int_array;
    b = vb as &bigarray;
    layout = vlayout as &i31 as i32_s;
    if b.ba_layout as i32_u != layout => &eq {
        num_dims = b.ba_num_dims as i32_u;
        dim = b.ba_dim;
        new_dim = [int_array| 0; num_dims];
        'loop_2: loop {
            if i <u num_dims {
                new_dim[i] = dim[num_dims - i - 1];
                i = i + 1;
                br 'loop_2;
            }
        } /* 'loop_2 */
        {bigarray|
            f: bigarray_ops,
            ba_data: b.ba_data,
            ba_dim: new_dim,
            ba_num_dims: num_dims,
            ba_kind: b.ba_kind as i32_u,
            ba_layout: layout
        };
    } else { vb; }
}
#[export = "caml_ba_num_dims"]
fn caml_ba_num_dims(x: &eq) -> &eq {
    (x as &bigarray).ba_num_dims as i32_u as &i31;
}
#[export = "caml_ba_kind"]
fn caml_ba_kind(x: &eq) -> &eq { (x as &bigarray).ba_kind as i32_u as &i31; }
#[export = "caml_ba_layout"]
fn caml_ba_layout(x: &eq) -> &eq {
    (x as &bigarray).ba_layout as i32_u as &i31;
}
fn caml_ba_compare(v1: &eq, v2: &eq, total: i32) -> i32 {
    let b1: &bigarray;
    let b2: &bigarray;
    let i1: i32;
    let i2: i32;
    let i: i32;
    let len: i32;
    let f1: f64;
    let f2: f64;
    let d1: &extern;
    let d2: &extern;
    b1 = v1 as &bigarray;
    b2 = v2 as &bigarray;
    if b2.ba_layout as i32_u != b1.ba_layout as i32_u {
        return (b2.ba_layout as i32_u - b1.ba_layout as i32_u);
    }
    if b2.ba_kind as i32_u != b1.ba_kind as i32_u {
        return (b2.ba_kind as i32_u - b1.ba_kind as i32_u);
    }
    if b2.ba_num_dims as i32_u != b1.ba_num_dims as i32_u {
        return (b2.ba_num_dims as i32_u - b1.ba_num_dims as i32_u);
    }
    len = b2.ba_num_dims as i32_u;
    'loop_2: loop {
        if i <u len {
            i1 = b1.ba_dim[i];
            i2 = b2.ba_dim[i];
            if i1 != i2 { return (i1 <u i2?-1:1); }
            i = i + 1;
            br 'loop_2;
        }
    } /* 'loop_2 */
    d1 = b1.ba_data;
    d2 = b2.ba_data;
    len = ta_length(d1);
    i = 0;
    'float32: {
        'float64: {
            'int8: {
                'uint8: {
                    'int16: {
                        'uint16: {
                            'int32: {
                                'int64: {
                                    br_table
                                        [ 'float32 'float64 'int8 'uint8
                                            'int16 'uint16 'int32 'int64
                                            'int32 'int32 'float32 'float64
                                            else 'uint8 ]
                                        b1.ba_kind as i32_u;
                                }
                                'loop_2: loop {
                                    if i <u len {
                                        i1 = ta_get_i32(d1, i + 1);
                                        i2 = ta_get_i32(d2, i + 1);
                                        if i1 <s i2 { return -1; }
                                        if i1 >s i2 { return 1; }
                                        i1 = ta_get_i32(d1, i);
                                        i2 = ta_get_i32(d2, i);
                                        if i1 <u i2 { return -1; }
                                        if i1 >u i2 { return 1; }
                                        i = i + 2;
                                        br 'loop_2;
                                    }
                                } /* 'loop_2 */
                                return 0;
                            } /* 'int32 */
                            'loop_2: loop {
                                if i <u len {
                                    i1 = ta_get_i32(d1, i);
                                    i2 = ta_get_i32(d2, i);
                                    if i1 <s i2 { return -1; }
                                    if i1 >s i2 { return 1; }
                                    i = i + 1;
                                    br 'loop_2;
                                }
                            } /* 'loop_2 */
                            return 0;
                        } /* 'uint16 */
                        'loop_2: loop {
                            if i <u len {
                                i1 = ta_get_ui16(d1, i);
                                i2 = ta_get_ui16(d2, i);
                                if i1 <s i2 { return -1; }
                                if i1 >s i2 { return 1; }
                                i = i + 1;
                                br 'loop_2;
                            }
                        } /* 'loop_2 */
                        return 0;
                    } /* 'int16 */
                    'loop_2: loop {
                        if i <u len {
                            i1 = ta_get_i16(d1, i);
                            i2 = ta_get_i16(d2, i);
                            if i1 <s i2 { return -1; }
                            if i1 >s i2 { return 1; }
                            i = i + 1;
                            br 'loop_2;
                        }
                    } /* 'loop_2 */
                    return 0;
                } /* 'uint8 */
                'loop_2: loop {
                    if i <u len {
                        i1 = ta_get_ui8(d1, i);
                        i2 = ta_get_ui8(d2, i);
                        if i1 <s i2 { return -1; }
                        if i1 >s i2 { return 1; }
                        i = i + 1;
                        br 'loop_2;
                    }
                } /* 'loop_2 */
                return 0;
            } /* 'int8 */
            'loop_2: loop {
                if i <u len {
                    i1 = ta_get_i8(d1, i);
                    i2 = ta_get_i8(d2, i);
                    if i1 <s i2 { return -1; }
                    if i1 >s i2 { return 1; }
                    i = i + 1;
                    br 'loop_2;
                }
            } /* 'loop_2 */
            return 0;
        } /* 'float64 */
        'loop_2: loop {
            if i <u len {
                f1 = ta_get_f64(d1, i);
                f2 = ta_get_f64(d2, i);
                if f1 < f2 { return -1; }
                if f1 > f2 { return 1; }
                if f1 != f2 {
                    if !total { return unordered; }
                    if f1 == f1 { return 1; }
                    if f2 == f2 { return -1; }
                }
                i = i + 1;
                br 'loop_2;
            }
        } /* 'loop_2 */
        return 0;
    } /* 'float32 */
    'loop_2: loop {
        if i <u len {
            f1 = ta_get_f32(d1, i);
            f2 = ta_get_f32(d2, i);
            if f1 < f2 { return -1; }
            if f1 > f2 { return 1; }
            if f1 != f2 {
                if !total { return unordered; }
                if f1 == f1 { return 1; }
                if f2 == f2 { return -1; }
            }
            i = i + 1;
            br 'loop_2;
        }
    } /* 'loop_2 */
    return 0;
}
#[export = "caml_ba_uint8_get16"]
fn caml_ba_uint8_get16(vba: &eq, i: &eq) -> &eq {
    let ba: &bigarray;
    let data: &extern;
    let p: i32;
    ba = vba as &bigarray;
    data = ba.ba_data;
    p = i as &i31 as i32_s;
    if p <s 0 { caml_bound_error(); }
    if p + 1 >=u ba.ba_dim[0] { caml_bound_error(); }
    ta_get16_ui8(data, p) as &i31;
}
#[export = "caml_ba_uint8_get32"]
fn caml_ba_uint8_get32(vba: &eq, i: &eq) -> i32 {
    let ba: &bigarray;
    let data: &extern;
    let p: i32;
    ba = vba as &bigarray;
    data = ba.ba_data;
    p = i as &i31 as i32_s;
    if p <s 0 { caml_bound_error(); }
    if p + 3 >=u ba.ba_dim[0] { caml_bound_error(); }
    become ta_get32_ui8(data, p);
}
#[export = "caml_ba_uint8_get64"]
fn caml_ba_uint8_get64(vba: &eq, i: &eq) -> i64 {
    let ba: &bigarray;
    let data: &extern;
    let p: i32;
    ba = vba as &bigarray;
    data = ba.ba_data;
    p = i as &i31 as i32_s;
    if p <s 0 { caml_bound_error(); }
    if p + 7 >=u ba.ba_dim[0] { caml_bound_error(); }
    ta_get32_ui8(data, p) as i64_u | ta_get32_ui8(data, p + 4) as i64_u << 32;
}
#[export = "caml_ba_uint8_set16"]
fn caml_ba_uint8_set16(vba: &eq, i: &eq, v: &eq) -> &eq {
    let ba: &bigarray;
    let data: &extern;
    let p: i32;
    let d: &i31;
    ba = vba as &bigarray;
    data = ba.ba_data;
    p = i as &i31 as i32_s;
    d = v as &i31;
    if p <s 0 { caml_bound_error(); }
    if p + 1 >=u ba.ba_dim[0] { caml_bound_error(); }
    ta_set16_ui8(data, p, d);
    0 as &i31;
}
#[export = "caml_ba_uint8_set32"]
fn caml_ba_uint8_set32(vba: &eq, i: &eq, d: i32) -> &eq {
    let ba: &bigarray;
    let data: &extern;
    let p: i32;
    ba = vba as &bigarray;
    data = ba.ba_data;
    p = i as &i31 as i32_s;
    if p <s 0 { caml_bound_error(); }
    if p + 3 >=u ba.ba_dim[0] { caml_bound_error(); }
    ta_set32_ui8(data, p, d);
    0 as &i31;
}
#[export = "caml_ba_uint8_set64"]
fn caml_ba_uint8_set64(vba: &eq, i: &eq, d: i64) -> &eq {
    let ba: &bigarray;
    let data: &extern;
    let p: i32;
    ba = vba as &bigarray;
    data = ba.ba_data;
    p = i as &i31 as i32_s;
    if p <s 0 { caml_bound_error(); }
    if p + 7 >=u ba.ba_dim[0] { caml_bound_error(); }
    ta_set32_ui8(data, p, d as i32);
    ta_set32_ui8(data, p + 4, (d >>u 32) as i32);
    0 as &i31;
}
#[export = "caml_string_of_array"]
fn caml_string_of_array(x: &eq) -> &eq {
    let a: &extern;
    let len: i32;
    let s: &string;
    a = (unwrap(x) as &?extern)!;
    len = ta_length(a);
    s = [string| 0; len];
    ta_blit_to_string(a, 0, s, 0, len);
    s;
}
#[export = "caml_uint8_array_of_string"]
fn caml_uint8_array_of_string(x: &eq) -> &eq {
    let ta: &extern;
    let len: i32;
    let s: &string;
    s = x as &string;
    len = s.length;
    ta = ta_create(3, len);
    ta_blit_from_string(s, 0, ta, 0, len);
    wrap(ta as &?any);
}
#[export = "caml_ba_get_kind"]
fn caml_ba_get_kind(x: &eq) -> i32 { (x as &bigarray).ba_kind as i32_u; }
#[export = "caml_ba_get_layout"]
fn caml_ba_get_layout(x: &eq) -> i32 { (x as &bigarray).ba_layout as i32_u; }
#[export = "caml_ba_get_data"]
fn caml_ba_get_data(x: &eq) -> &extern { (x as &bigarray).ba_data; }
#[export = "caml_ba_set_data"]
fn caml_ba_set_data(x: &eq, x_2: &extern) { (x as &bigarray).ba_data = x_2; }
#[export = "caml_ba_get_dim"]
fn caml_ba_get_dim(x: &eq) -> &int_array { (x as &bigarray).ba_dim; }
#[export = "caml_ba_alloc"]
fn caml_ba_alloc
(kind: i32, layout: i32, num_dims: i32, data: &extern, dim: &int_array) ->
&eq {
    {bigarray|
        f: bigarray_ops,
        ba_data: data,
        ba_dim: dim,
        ba_num_dims: num_dims,
        ba_kind: kind,
        ba_layout: layout
    };
}
#[export = "string_set"]
fn string_set(s: &?extern, i: i32, v: i32) {
    (s as &?any as &?string)[i] = v;
}
#[export = "string_get"]
fn string_get(s: &?extern, i: i32) -> i32 {
    (s as &?any as &?string)[i] as i32_u;
}
