- how to deal with functions returning multiple values?
  (in generated binary code)
  ==> maybe just have a destructuring let?
  note that (x, y, z) is just a sequence of instructions
    let (x,y) = (u, v) ==> u v (locat.set $y) (local.set $x)
- syntax errors
- typing
- output wasm code
- parse wasm code and output to this format
- type for 8bit/16bit values + explicit type expansion
- validation of wasm code
- switch translated to br_table?
    match (foo) {
    1 => ..,
    2 => ..,
    _ => ..
    }
- same for try/catch
    try (body) { a => br x, ..., _ => br z}
  (not sure this works well)

====

allow to put block labels at the end?
collect constraints on untyped variables while parsing

simplify parser (type use)


Folding:
- stack with placeholders for value that do not correspond
  to an expression (multiple returns / block inputs)
- peek an instruction; compute its arity and peek arguments from the stack
  if no return value, emit instruction; otherwise;
  push on the stack with count of return values
- at end of block; write stack contents

Keep strings as strings

Precedence tests (read and write text and check unchanged)

When inheriting, we can omit existing fields

   type int32 : custom = { .., foo: i32 }

make semicolon optional at end of block; allow comma at end of block

include a file (e.g. common types, imports)

conditional compilation using attributes

Use typechecking to eliminate unnecessary type annotations
  - we know the number type for other reasons
  - the value is known to have a more precise type

Two-step inference?
  - preserve overloading of number functions
  - propagate type in all directions (simple unification / union find?)

============

br 'foo ...
labels
array operations (array.new, array.new_fixed, array.get, array.set)
drop instruction (==> let _ =)
ref.as_non_null (need types?)
more ops: shr, ...
we need to put constraints on integer/float constants and eliminate afterwards
=====

fn caml_string_equal(p1: &eq, p2: &eq) -> &eq {
  if p1 == p2 { return 1 }
  let s1 = p1 as &string;
  let s2 = p2 as &string;
  let len = array_len(s1);
  if len != array_len(s2) { return 0 }
  for (let i; i++; i <s len) {
    if unsigned(s1[i]) != unsigned(s2[i]) { return 0 }
  }
  1
}
