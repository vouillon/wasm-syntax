(* 
   Analysis and Error Message Generation for Menhir .messages files.
   
   This tool provides functionality to:
   1. Parse .messages files.
   2. Analyze grammar to understand symbol expansions.
   3. Generate user-friendly error messages using heuristics.
*)

module StringSet = Set.Make (String)
module StringMap = Map.Make (String)
module StatusMap = Map.Make (String)

type status = Direct | Lookahead | Both

(* --- Grammar Analysis Utilities --- *)

(* Build a grammar (LHS -> RHS list map) from all LR items in the file *)
let build_grammar entries =
  List.fold_left
    (fun acc entry ->
      List.fold_left
        (fun acc item ->
          let lhs = item.Parse_messages.lhs in
          let rhs =
            item.Parse_messages.rhs_before @ item.Parse_messages.rhs_after
          in
          let existing = try StringMap.find lhs acc with Not_found -> [] in
          if List.mem rhs existing then acc
          else StringMap.add lhs (rhs :: existing) acc)
        acc entry.Parse_messages.data.lr1_items)
    StringMap.empty entries

(* Strips constructors like option(), list(), etc. to get the inner symbol *)
let strip_constructor s =
  let open String in
  let len = length s in

  let extract_content prefix_len suffix_len =
    sub s prefix_len (len - prefix_len - suffix_len)
  in

  if starts_with ~prefix:"loption(" s && ends_with ~suffix:")" s then
    extract_content 8 1
  else if starts_with ~prefix:"option(" s && ends_with ~suffix:")" s then
    extract_content 7 1
  else if starts_with ~prefix:"boption(" s && ends_with ~suffix:")" s then
    extract_content 8 1
  else if starts_with ~prefix:"list(" s && ends_with ~suffix:")" s then
    extract_content 5 1
  else if starts_with ~prefix:"nonempty_list(" s && ends_with ~suffix:")" s then
    extract_content 14 1
  else if starts_with ~prefix:"separated_list(" s && ends_with ~suffix:")" s
  then
    let content = extract_content 15 1 in
    match split_on_char ',' content with _ :: x :: _ -> trim x | _ -> s
  else if
    starts_with ~prefix:"separated_nonempty_list(" s && ends_with ~suffix:")" s
  then
    let content = extract_content 24 1 in
    match split_on_char ',' content with _ :: x :: _ -> trim x | _ -> s
  else s

(* Check if a symbol involves an anonymous symbol generated by Menhir *)
let involves_anonymous s =
  let pattern = "__anonymous" in
  let plen = String.length pattern in
  let slen = String.length s in
  let rec check i =
    if i + plen > slen then false
    else if String.sub s i plen = pattern then true
    else check (i + 1)
  in
  check 0

(* Check if a symbol is nullable (heuristic based on name) *)
let is_nullable_symbol s =
  let prefixes = [ "option("; "boption("; "loption("; "list(" ] in
  List.exists
    (fun prefix ->
      String.length s >= String.length prefix
      && String.sub s 0 (String.length prefix) = prefix)
    prefixes

(* Recursively expand non-terminals to find the set of first terminals/symbols they can produce *)
let rec expand_symbol grammar visited s =
  if StringSet.mem s visited then StringSet.empty (* Cycle detection *)
  else
    let visited' = StringSet.add s visited in

    (* Attempt 1: Expand via grammar if applicable (for anonymous symbols) *)
    let try_grammar () =
      if involves_anonymous s then
        match StringMap.find_opt s grammar with
        | Some productions ->
            let result =
              List.fold_left
                (fun acc rhs ->
                  match rhs with
                  | [] -> acc (* Empty production *)
                  | first :: _ ->
                      let firsts = expand_symbol grammar visited' first in
                      StringSet.union acc firsts)
                StringSet.empty productions
            in
            Some result
        | None -> None
      else None
    in

    match try_grammar () with
    | Some res -> res
    | None ->
        (* Attempt 2: Unwrap constructors *)
        let s_unwrapped = strip_constructor s in
        if s_unwrapped <> s then
          (* Recurse on unwrapped *)
          expand_symbol grammar visited' s_unwrapped
        else
          (* Terminal or opaque non-terminal found *)
          StringSet.singleton s

(* Helper for StatusMap *)
let add_status s status map =
  let new_status =
    match StatusMap.find_opt s map with
    | None -> status
    | Some old -> if old = status then old else Both
  in
  StatusMap.add s new_status map

let union_status map1 map2 =
  StatusMap.fold (fun s status acc -> add_status s status acc) map2 map1

(* 
   Collect all possible next symbols (continuations) given the RHS after the dot.
   Handles nullability to look past nullable symbols.
*)
let rec collect_continuations grammar visited rhs_after lookaheads =
  match rhs_after with
  | [] ->
      List.fold_left
        (fun acc s -> add_status s Lookahead acc)
        StatusMap.empty lookaheads
  | symbol :: rest ->
      (* Expand the symbol *)
      let expanded = expand_symbol grammar visited symbol in

      let base_map =
        StringSet.fold
          (fun s acc -> add_status s Direct acc)
          expanded StatusMap.empty
      in
      let acc = base_map in

      if is_nullable_symbol symbol then
        let rest_map = collect_continuations grammar visited rest lookaheads in
        union_status acc rest_map
      else acc

(* --- Depth Calculation --- *)

(* 
   Find depth of the matching opener for a given closer.
   Depth is defined as the 1-based index from the top of the stack (right end of the sentence).
   Every token counts as depth 1. 
*)
let find_matching_depth sentence closer =
  let tokens =
    String.split_on_char ' ' sentence
    |> List.map String.trim
    |> List.filter (fun s -> s <> "")
  in
  let reversed = List.rev tokens in

  let rec scan depth balance items =
    match items with
    | [] -> None (* Not found *)
    | token :: rest -> (
        let current_depth = depth + 1 in
        match (closer, token) with
        | "RBRACE", "RBRACE" -> scan current_depth (balance + 1) rest
        | "RBRACE", "LBRACE" ->
            if balance > 0 then scan current_depth (balance - 1) rest
            else Some current_depth
        | "RBRACKET", "RBRACKET" -> scan current_depth (balance + 1) rest
        | "RBRACKET", "LBRACKET" ->
            if balance > 0 then scan current_depth (balance - 1) rest
            else Some current_depth
        | "RPAREN", "RPAREN" -> scan current_depth (balance + 1) rest
        | ( "RPAREN",
            ( "STRING_ANNOT" | "LPAREN" | "LPAREN_CATCH" | "LPAREN_CATCH_ALL"
            | "LPAREN_CATCH_ALL_REF" | "LPAREN_CATCH_REF" | "LPAREN_EXPORT"
            | "LPAREN_IMPORT" | "LPAREN_LOCAL" | "LPAREN_PARAM"
            | "LPAREN_RESULT" | "LPAREN_THEN" | "LPAREN_TYPE" ) ) ->
            if balance > 0 then scan current_depth (balance - 1) rest
            else Some current_depth
        | _ -> scan current_depth balance rest)
  in
  scan 0 0 reversed

(* --- Terminal Alias Loading --- *)

let load_terminals filename =
  let mapping = Hashtbl.create 100 in
  let chan = open_in filename in
  let re_token =
    Str.regexp
      "%token[ \t]+\\(<[^>]+>\\)?[ \t]*\\([A-Z_0-9]+\\)[ \t]*\\(\"[^\"]+\"\\)?"
  in
  let debug_count = ref 0 in
  try
    while true do
      let line = input_line chan in
      if Str.string_match re_token line 0 then
        let name = Str.matched_group 2 line in
        let alias_opt =
          try Some (Str.matched_group 3 line) with Not_found -> None
        in
        match alias_opt with
        | Some s ->
            let alias = String.sub s 1 (String.length s - 2) in
            (* Printf.printf "Loaded alias: %s -> %s\n" name alias; *)
            Hashtbl.add mapping name alias
        | None -> ()
      else if !debug_count < 5 then
        (* Printf.printf "Failed to match: '%s'\n" line; *)
        incr debug_count
    done;
    mapping
  with End_of_file ->
    close_in chan;
    mapping

(* --- Message Generation --- *)

let format_human_list items =
  match List.rev items with
  | [] -> ""
  | [ x ] -> x
  | last :: rest -> String.concat ", " (List.rev rest) ^ ", or " ^ last

let get_readable_name terminals s =
  try Printf.sprintf "'%s'" (Hashtbl.find terminals s)
  with Not_found -> (
    match s with
    | "IDENT" -> "an identifier"
    | "INT" -> "an integer"
    | "FLOAT" -> "a float"
    | "STRING" -> "a string"
    | "CHAR" -> "a character"
    | "EOF" -> "end of file"
    | "u8" -> "an 8-bit unsigned integer"
    | "u32" -> "a 32-bit unsigned integer"
    | "u64" -> "a 64-bit unsigned integer"
    | "i8" -> "an 8-bit signed integer"
    | "i16" -> "a 16-bit signed integer"
    | "i32" -> "a 32-bit signed integer"
    | "i64" -> "a 64-bit signed integer"
    | "f32" -> "a 32-bit float"
    | "f64" -> "a 64-bit float"
    | "LPAREN_IMPORT" -> "an inline import"
    | "NAT" -> "an integer"
    | "MEM_OFFSET" -> "a memory offset"
    | "MEM_ALIGN" -> "a memory alignment"
    | _ ->
        if String.lowercase_ascii s = s then
          (* Non-terminals: "some_name" -> "a/an some name" *)
          let parts = String.split_on_char '_' s in
          let parts = List.filter (fun p -> p <> "") parts in
          if parts = [] then s
          else
            let name = String.concat " " parts in
            match parts with
            | p :: _ ->
                let c = String.get p 0 in
                (* Avoid "a parameters", "a definitions" etc. *)
                let is_plural =
                  String.length p > 1
                  && String.sub p (String.length p - 1) 1 = "s"
                  && not
                       (List.mem p
                          [ "as"; "is"; "this"; "plus"; "minus"; "address" ])
                in
                if is_plural then name
                else if List.mem c [ 'a'; 'e'; 'i'; 'o'; 'u' ] then "an " ^ name
                else "a " ^ name
            | _ -> name
        else
          (* Keywords/Other Terminals: "TOKEN" -> "'token'" *)
          "'" ^ String.lowercase_ascii s ^ "'")

let generate_message grammar terminals entry =
  let d = entry.Parse_messages.data in

  (* Calculate Valid Next Symbols *)
  let valid_next =
    List.fold_left
      (fun acc item ->
        let next_map =
          collect_continuations grammar StringSet.empty
            item.Parse_messages.rhs_after item.Parse_messages.lookaheads
        in
        union_status acc next_map)
      StatusMap.empty d.lr1_items
  in
  let valid_symbols = StatusMap.bindings valid_next |> List.map fst in

  let sentence =
    if d.stack_suffix <> [] then String.concat " " d.stack_suffix
    else entry.Parse_messages.sentence
  in

  (* Output: Original Sentence and Comments *)
  if entry.Parse_messages.original_comments <> [] then
    Printf.printf "%s: %s\n%s\n\n" entry.Parse_messages.entry_point
      entry.Parse_messages.sentence
      (String.concat "\n" entry.Parse_messages.original_comments)
  else
    Printf.printf "%s: %s\n\n" entry.Parse_messages.entry_point
      entry.Parse_messages.sentence;

  (* Heuristic: Formatting Logic *)
  let readable_name = get_readable_name terminals in

  (* Heuristic: Expected Symbols *)
  let expected_symbols =
    valid_symbols
    |> List.filter (fun s -> not (involves_anonymous s)) (* Filter anonymous *)
    |> List.sort_uniq String.compare
    |> List.map readable_name
    |> List.sort_uniq String.compare
  in

  (* Heuristic: Unclosed Delimiters *)
  let check_unclosed closer opener_str friendly_name =
    if List.mem closer valid_symbols then
      match find_matching_depth sentence closer with
      | Some depth -> Some (depth, opener_str, friendly_name)
      | None -> None
    else None
  in

  let unclosed_details =
    match check_unclosed "RBRACE" "{" "brace" with
    | Some x -> Some x
    | None -> (
        match check_unclosed "RBRACKET" "[" "bracket" with
        | Some x -> Some x
        | None -> check_unclosed "RPAREN" "(" "parenthesis")
  in

  (* Construct Error Message *)
  let base_message =
    if List.length expected_symbols > 0 && List.length expected_symbols <= 5
    then Printf.sprintf "Expecting %s." (format_human_list expected_symbols)
    else "Syntax error"
  in

  let message_body =
    match List.rev d.spurious_reductions with
    | [] -> base_message
    | last :: _ ->
        let raw_name = readable_name last.symbol in
        let name, verb =
          if String.length raw_name > 2 && String.sub raw_name 0 2 = "a " then
            (String.sub raw_name 2 (String.length raw_name - 2), "is")
          else if String.length raw_name > 3 && String.sub raw_name 0 3 = "an "
          then (String.sub raw_name 3 (String.length raw_name - 3), "is")
          else if String.length raw_name > 0 && String.get raw_name 0 = '\''
          then (raw_name, "is")
          else (raw_name, "are")
        in
        Printf.sprintf "Assuming that the %s %s complete, %s" name verb
          (if base_message = "Syntax error" then "syntax error."
           else String.uncapitalize_ascii base_message)
  in

  (* Append Hint if an unclosed delimiter was detected on the stack context *)
  let full_message =
    match unclosed_details with
    | Some (depth, opener, _) ->
        message_body ^ "\n"
        ^ Printf.sprintf "<%d>This '%s' might be unmatched." depth opener
    | None -> message_body
  in

  Printf.printf "%s\n\n" full_message

(* Analysis: List all possible continuations for states, indicating spurious reductions. *)
let analyze_transitions entries =
  let grammar = build_grammar entries in
  let seen_states = Hashtbl.create 100 in

  Printf.printf "Transitions per state:\n";

  let process_entry entry =
    let d = entry.Parse_messages.data in
    if not (Hashtbl.mem seen_states d.state) then (
      Hashtbl.add seen_states d.state ();

      let all_next =
        List.fold_left
          (fun acc item ->
            let next_map =
              collect_continuations grammar StringSet.empty
                item.Parse_messages.rhs_after item.Parse_messages.lookaheads
            in
            union_status acc next_map)
          StatusMap.empty d.lr1_items
      in

      let symbols = StatusMap.bindings all_next in
      (match List.rev d.spurious_reductions with
      | [] -> Printf.printf "State %d:\n" d.state
      | last :: _ ->
          Printf.printf "State %d (spurious reduction: %s):\n" d.state
            last.symbol);

      let sentence =
        if d.stack_suffix <> [] then String.concat " " d.stack_suffix
        else entry.Parse_messages.sentence
      in

      List.iter
        (fun (s, status) ->
          let note =
            match status with
            | Direct -> ""
            | Lookahead -> " [lookahead]"
            | Both -> " [lookahead]"
          in

          let warning =
            match s with
            | "RBRACE" | "RBRACKET" | "RPAREN" -> (
                match find_matching_depth sentence s with
                | Some depth -> Printf.sprintf " [depth: %d]" depth
                | None -> " [mismatch?]")
            | _ -> ""
          in

          Printf.printf "  %s%s%s\n" s note warning)
        symbols)
  in

  List.iter process_entry entries

(* --- Main Entry Point --- *)

let main () =
  let input_file = ref "" in
  let generate_messages = ref false in
  let list_transitions = ref false in
  let terminals_file = ref "wax.mly" in

  let spec =
    [
      ( "-generate-messages",
        Arg.Set generate_messages,
        "Generate error messages for states" );
      ( "-list-transitions",
        Arg.Set list_transitions,
        "List all possible continuations for states" );
      ( "-terminals",
        Arg.Set_string terminals_file,
        "Path to the .mly file containing terminal definitions (default: \
         wax.mly)" );
    ]
  in

  let usage_msg = "Usage: main.exe [options] <filename.messages>" in

  Arg.parse spec (fun f -> input_file := f) usage_msg;

  if !input_file = "" then (
    Arg.usage spec usage_msg;
    exit 1);

  let entries = Parse_messages.parse_file !input_file in
  Printf.eprintf "Parsed %d entries from %s\n" (List.length entries) !input_file;

  if !generate_messages then (
    let terminals = load_terminals !terminals_file in
    let grammar = build_grammar entries in
    Printf.eprintf "Generating messages...\n";
    List.iter (generate_message grammar terminals) entries)
  else if !list_transitions then analyze_transitions entries
  else if
    (* Default verification dump *)
    entries <> []
  then (
    let first = List.hd entries in
    Printf.printf "First Entry State: %d\n" first.data.state;
    Printf.printf "First Entry Info: %d items\n"
      (List.length first.data.lr1_items))

let () = main ()
