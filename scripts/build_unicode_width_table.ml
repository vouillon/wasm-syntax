let char_width c =
  if c >= 0xD800 && c <= 0xDFFF then 1
  else
    let u = Uchar.of_int c in
    match Uucp.Hangul.syllable_type u with
    | `V | `T -> 0
    | _ -> (
        if Uucp.Gen.is_default_ignorable u then 0
        else
          match Uucp.Gc.general_category u with
          | `Mn | `Me | `Cc | `Cf -> 0
          | _ -> (
              match Uucp.Break.east_asian_width u with `W | `F -> 2 | _ -> 1))

let max_codepoint = 0x10FFFF
let block_size = 256
let chunks_per_block = block_size / 4

let pack_byte w0 w1 w2 w3 =
  w0 land 0x3
  lor ((w1 land 0x3) lsl 2)
  lor ((w2 land 0x3) lsl 4)
  lor ((w3 land 0x3) lsl 6)

let byte_to_hex b = Printf.sprintf "\\x%02x" b

let () =
  let blocks = Hashtbl.create 1024 in
  let stage1_indices = Buffer.create 2048 in
  let unique_blocks = ref [] in
  let next_block_index = ref 0 in
  let num_high_pages = (max_codepoint / block_size) + 1 in
  for page = 0 to num_high_pages - 1 do
    let current_block = Buffer.create chunks_per_block in
    for chunk = 0 to chunks_per_block - 1 do
      let base = (page * block_size) + (chunk * 4) in
      let w0 = if base + 0 > max_codepoint then 1 else char_width (base + 0) in
      let w1 = if base + 1 > max_codepoint then 1 else char_width (base + 1) in
      let w2 = if base + 2 > max_codepoint then 1 else char_width (base + 2) in
      let w3 = if base + 3 > max_codepoint then 1 else char_width (base + 3) in
      Buffer.add_char current_block (Char.chr (pack_byte w0 w1 w2 w3))
    done;
    let block_str = Buffer.contents current_block in
    let idx =
      match Hashtbl.find_opt blocks block_str with
      | Some i -> i
      | None ->
          let i = !next_block_index in
          Hashtbl.add blocks block_str i;
          unique_blocks := block_str :: !unique_blocks;
          incr next_block_index;
          i
    in
    if !next_block_index > 255 then
      failwith "Error: Too many unique blocks (>256).";
    Buffer.add_char stage1_indices (Char.chr idx)
  done;
  Printf.printf "(* Auto-generated by scripts/build_unicode_width_table *)\n\n";
  (* Print Stage 1 Table *)
  Printf.printf "let stage1_indices = \"";
  String.iter
    (fun c -> Printf.printf "%s" (byte_to_hex (Char.code c)))
    (Buffer.contents stage1_indices);
  Printf.printf "\"\n\n";
  (* Print Stage 2 Table *)
  let stage2_data = String.concat "" (List.rev !unique_blocks) in
  Printf.printf "let stage2_blocks = \"";
  String.iter
    (fun c -> Printf.printf "%s" (byte_to_hex (Char.code c)))
    stage2_data;
  Printf.printf "\"\n\n";
  Printf.printf "let get_width cp =\n";
  Printf.printf "  if cp > 0x10FFFF then 1 else\n";
  Printf.printf
    "  let block_idx = Char.code (String.get stage1_indices (cp lsr 8)) in\n";
  Printf.printf
    "  let byte_offset = (block_idx lsl 6) + ((cp land 0xFF) lsr 2) in\n";
  Printf.printf
    "  let packed = Char.code (String.get stage2_blocks byte_offset) in\n";
  Printf.printf "  (packed lsr ((cp land 3) lsl 1)) land 3\n"
